/**********************************************************/
/*アナログ-デジタル変換関数ライブラリ                     */
/*2011.12.30                                              */
/**********************************************************/
#include "p33Fxxxx.h"
#include "adclib.h"
#include "delaylib.h"

//====ADC1 10bitモード初期化関数=============================================================
void ADC1_10bit_Init(int PCFG)
{
	//----AD1CON1:ADC1制御レジスタ1----
	//ADC動作モードビット
	AD1CON1bits.ADON = 0;		//ADCモジュール無効
	//アイドルモード時停止ビット
	AD1CON1bits.ADSIDL = 0;		//アイドルモード中もモジュールの動作を継続
	//DMAバッファビルドモードビット
	//AD1CON1bits.ADDMABM = 0;	//Scatter/GatherモードでDMAバッファに書き込む
	//10ビット/12ビット動作モードビット
	AD1CON1bits.AD12B = 0;		//10ビット
	//データ出力フォーマットビット
	AD1CON1bits.FORM = 0;		//0000 00 DD DDDD DDDD
	//サンプルクロック源選択ビット
	AD1CON1bits.SSRC = 0;		//サンプリングビットがクリアされたときにサンプリング終了/変換開始をトリガする
	//同期サンプリング選択ビット
	AD1CON1bits.SIMSAM = 0;		//複数チャンネルを逐次サンプリングする
	//ADCサンプル自動開始ビット
	AD1CON1bits.ASAM = 0;	//変換後次のサンプリングを自動的に開始する
	//ADCサンプルイネーブルビット
	AD1CON1bits.SAMP = 0;		//ADC S&Hアンプはサンプリングを待機する
	//ADC変換ステータスビット
	AD1CON1bits.DONE = 0;		//読み込み専門、ソフトウェアで１は書き込めません
	
	//----ADC1CON2:ADC1制御レジスタ2----
	//コンバータ電圧リファレンスコンフィグレーションビット
	AD1CON2bits.VCFG = 0;		//VREFH = AVDD/VREFL = AVSS
	//入力スキャン選択ビット
	AD1CON2bits.CSCNA = 0;		//入力をスキャンしない
	//チャンネル選択ビット
	AD1CON2bits.CHPS = 0;		//CH0を変換する
	//バッファ書き込みステータスビット
	AD1CON2bits.BUFS = 0;		//ADCは現在バッファの前半部に書き込んでいる
	//サンプリング/変換動作ビット
	AD1CON2bits.SMPI = 0;		//1回のサンプリング/変換動作が完了するごとにADC割り込みを発生させる
	//バッファ書き込みモード選択ビット
	AD1CON2bits.BUFM = 0;		//常に先頭アドレスからバッファの書き込みを開始する。
	//交互入力サンプルモード選択ビット
	AD1CON2bits.ALTS = 0;		//常にサンプルA用チャンネル入力選択を使用する
	
	//----AD1CON3:ADC1制御レジスタ3----
	//ADC変換クロック源ビット
	AD1CON3bits.ADRC = 0;		//分周したシステムクロックを使用する
	//自動サンプリング時間ビット
	AD1CON3bits.SAMC = 0x04;	//4TAD
	//ADC変換クロック選択ビット
	AD1CON3bits.ADCS = 0x05;	//TCY * (ADCS + 1) = TCY * 6 = TAD
	
	//----AD1CON4:ADC1制御レジスタ4----
	//アナログ入力あたりのDMAバッファ割り当てビット
	//AD1CON4bits.DMABL = 0;		//各アナログ入力に1ワードバッファを割り当てる
	
	//----AD1CH123:ADC1入力チャンネル1/2/3選択レジスタ----
	//サンプルBのチャンネル1/2/3負極性入力選択ビット
	AD1CHS123bits.CH123NB = 0;	//CH1,CH2,CH3負極性入力にVREFLを選択する
	//サンプルBのチャンネル1/2/3正極性入力選択ビット
	AD1CHS123bits.CH123SB = 0;	//CH1正極性入力にAN0、CH2正極性入力にAN1、CH3正極性入力にAN2を選択する
	//サンプルAのチャンネル1/2/3負極性入力選択ビット
	AD1CHS123bits.CH123NA = 0;	//CH1、CH2、CH3負極性入力にVREFLを選択する
	//サンプルA のチャンネル1/2/3 正極性入力選択ビット
	AD1CHS123bits.CH123SA = 0;	//CH1正極性入力にAN0、CH2正極性入力にAN1、CH3正極性入力にAN2を選択する
	
	//----AD1CHS0:ADC1入力チャンネル0選択レジスタ----
	//サンプルB のチャンネル0 負極性入力選択ビット
	AD1CHS0bits.CH0NB = 0;		//チャンネル0 負極性入力にVREFL を選択する
	//サンプルB のチャンネル0 正極性入力選択ビット
	AD1CHS0bits.CH0SB = 0;		//チャンネル0 正極性入力にAN0 を選択する
	//サンプルA のチャンネル0 負極性入力選択ビット
	AD1CHS0bits.CH0NA = 0;		//チャンネル0 負極性入力にVREFL を選択する
	//サンプルA のチャンネル0 正極性入力選択ビット
	AD1CHS0bits.CH0SA = 0;		//チャンネル0 正極性入力にAN0 を選択する
	
	//----AD1CSSH:ADC1入力スキャン選択レジスタHIGH----
	//ADC入力スキャン選択ビット
	//AD1CSSHbits.CSS = 0;		//入力スキャンにANxを選択しない
	
	//----AD1CSSL:ADC1入力スキャン選択レジスタLOW----
	//ADC入力スキャン選択ビット
	//AD1CSSL = 0;				//入力スキャンにANxを選択しない
	
	//----AD1PCFGH:ADC1ポートコンフィグレーションレジスタHIGH----
	//ADCポートコンフィグレーション制御ビット
	//AD1PCFGHbits.PCFG = 0xFFFF;	//AN16~AN31すべてデジタルモードで使用する
	
	//----AD1PCFGL:ADC1ポートコンフィグレーションレジスタLOW----
	//ADCポートコンフィグレーション制御ビット
	//1111 11
	//5432 1098 7654 3210
	//1111 0001 1111 1111
	AD1PCFGL = PCFG;			//デジタルモード、アナログモードの設定
}

//====ADC1 12bitモード初期化関数================================================
void ADC1_12bit_Init(int PCFG)
{
	ADC1_10bit_Init(PCFG);
	
	//----AD1CON1:ADC1制御レジスタ1----
	//10ビット/12ビット動作モードビット
	AD1CON1bits.AD12B = 1;	//12ビット
	
	//----AD1CON3:ADC1制御レジスタ3---
	//ADC変換クロック選択ビット
	AD1CON3bits.ADCS = 0x06;	//TCY * (ADCS + 1) = TCY * 4 = TAD
}

//====ADC１チャンネルデータ取得関数=============================================
int ADC1_GetData(int Ch)
{
	AD1CON1bits.ADON = 0;		//ADCモジュール無効
	AD1CHS0 = Ch;				//チャンネル選択
	AD1CON1bits.ADON = 1;		//ADCモジュール有効
	AD1CON1bits.SAMP = 1;		//ADC S&Hアンプはサンプリングを実行する
	delay_us(20);				//コンデンサに電荷をためる
	AD1CON1bits.SAMP = 0;		//ADC S&Hアンプはサンプリングを待機
	while(!AD1CON1bits.DONE);	//DONEビットが立つまで待機
	return(ADC1BUF0);			//変換値を返す
}


