CCS PCM C Compiler, Version 3.185, 22500

               Filename: C:\Users\FMV\Dropbox\PIC-project\PIC CCS\AD変換\PIC16F877aAD電圧計測.LST

               ROM used: 861 (11%)
                         Largest free fragment is 2048
               RAM used: 14 (8%) at main() level
                         32 (18%) worst case
               Stack:    1 locations

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   2B8
0003:  NOP
....................  /*********************************************  
.................... このプログラムは電圧を図るプログラムです  
....................   
....................   
.................... **********************************************/  
.................... #include<16F877a.h> 
....................  //////// Standard Header file for the PIC16F877A device ////////////////  
.................... #device PIC16F877A  
.................... #list  
....................  
.................... #include<stdio.h> 
....................  ///////////////////////////////////////////////////////////////////////////  
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////  
.................... //// This source code may only be used by licensed users of the CCS C  ////  
.................... //// compiler.  This source code may only be distributed to other      ////  
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////  
.................... //// or distribution is permitted without written permission.          ////  
.................... //// Derivative programs created using this software in object code    ////  
.................... //// form are not restricted in any way.                               ////  
.................... ///////////////////////////////////////////////////////////////////////////  
....................   
.................... #ifndef _STDIO  
.................... #define _STDIO  
.................... #include <string.h> 
....................  ////////////////////////////////////////////////////////////////////////////  
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////  
.................... //// This source code may only be used by licensed users of the CCS C   ////  
.................... //// compiler.  This source code may only be distributed to other       ////  
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////  
.................... //// or distribution is permitted without written permission.           ////  
.................... //// Derivative programs created using this software in object code     ////  
.................... //// form are not restricted in any way.                                ////  
.................... ////////////////////////////////////////////////////////////////////////////  
....................   
.................... #ifndef _STRING  
.................... #define _STRING  
.................... #include <stddef.h> 
....................  ///////////////////////////////////////////////////////////////////////////  
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////  
.................... //// This source code may only be used by licensed users of the CCS C  ////  
.................... //// compiler.  This source code may only be distributed to other      ////  
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////  
.................... //// or distribution is permitted without written permission.          ////  
.................... //// Derivative programs created using this software in object code    ////  
.................... //// form are not restricted in any way.                               ////  
.................... ///////////////////////////////////////////////////////////////////////////  
....................   
.................... #ifndef _STDDEF  
....................   
.................... #define _STDDEF  
....................   
.................... #if sizeof(int *)==1  
.................... #define ptrdiff_t int  
.................... #else  
.................... #define ptrdiff_t long  
.................... #endif  
....................   
.................... #define size_t int  
.................... #define wchar_t char  
.................... #define NULL 0  
....................   
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)  
....................   
.................... #endif  
....................  
.................... #include <ctype.h> 
....................  ////////////////////////////////////////////////////////////////////////////  
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////  
.................... //// This source code may only be used by licensed users of the CCS C   ////  
.................... //// compiler.  This source code may only be distributed to other       ////  
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////  
.................... //// or distribution is permitted without written permission.           ////  
.................... //// Derivative programs created using this software in object code     ////  
.................... //// form are not restricted in any way.                                ////  
.................... ////////////////////////////////////////////////////////////////////////////  
....................   
.................... #ifndef _CTYPE  
.................... #define _CTYPE  
....................   
.................... #define islower(x)  isamoung(x,"abcdefghijklmnopqrstuvwxyz")  
.................... #define isupper(x)  isamoung(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")  
.................... #define isalnum(x)  isamoung(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")  
.................... #define isalpha(x)  isamoung(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")  
.................... #define isdigit(x)  isamoung(x,"0123456789")  
.................... #define isspace(x)  (x==' ')  
.................... #define isxdigit(x) isamoung(x,"0123456789ABCDEFabcdef")  
.................... #define iscntrl(x)  (x<' ')  
.................... #define isprint(x)  (x>=' ')  
.................... #define isgraph(x)  (x>' ')  
.................... #define ispunct(x)  ((x>' ')&&!isalnum(x))  
....................   
.................... #endif  
....................   
....................  
....................   
....................   
....................   
.................... //////////////////////////////////////////////  
.................... //// Uncomment the following define to    ////  
.................... //// allow some functions to use a        ////  
.................... //// quicker algorithm, but use more ROM  ////  
.................... ////                                      ////  
.................... //// #define FASTER_BUT_MORE_ROM          ////  
.................... //////////////////////////////////////////////  
....................   
....................   
....................   
.................... /*Copying functions*/  
.................... /* standard template:  
....................    void *memmove(void *s1, void *s2, size_t n).  
....................    Copies max of n characters safely (not following ending '\0')  
....................    from s2 in s1; if s2 has less than n characters, appends 0 */  
....................   
.................... char *memmove(void *s1,char *s2,size_t n)  
.................... {  
....................    char *sc1;  
....................    char *sc2;  
....................    sc1=s1;  
....................    sc2=s2;  
....................    if(sc2<sc1 && sc1 <sc2 +n)  
....................       for(sc1+=n,sc2+=n;0<n;--n)  
....................          *--sc1=*--sc2;  
....................    else  
....................       for(;0<n;--n)  
....................          *sc1++=*sc2++;  
....................   return s1;  
....................   }  
.................... /*    Standard template: char *strcpy(char *s1, const char *s2)  
.................... copies the string s2 including the null character to s1*/  
....................   
.................... char *strcpy(char *s1, char *s2)  
.................... {  
....................   char *s;  
....................   
....................   for (s = s1; *s2 != 0; s++, s2++)  
.................... 	  *s = *s2;  
....................   return(s1);  
.................... }  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved?? 
....................    Standard template: char *strcpy(char *s1, const char *s2)  
....................    copies the string s2 including the null character to s1*/  
....................   
.................... char *strcopy(char *s1, char *s2)  
.................... {  
....................   char *s;  
....................   
....................   for (s = s1; *s2 != 0; s++, s2++)  
.................... 	  *s = *s2;  
....................   return(s1);  
.................... }  
....................   
.................... /* standard template:  
....................    char *strncpy(char *s1, const char *s2, size_t n).  
....................    Copies max of n characters (not following ending '\0')  
....................    from s2 in s1; if s2 has less than n characters, appends 0 */  
....................   
.................... char *strncpy(char *s1, char *s2, size_t n)  
.................... {  
....................   char *s;  
....................   
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)  
....................      *s++ = *s2++;  
....................   for (; n > 0; n--)  
....................      *s++ = '\0';  
....................   
....................   return(s1);  
.................... }  
.................... /***********************************************************/  
....................   
.................... /*concatenation functions*/  
.................... /* standard template: char *strcat(char *s1, const char *s2)  
.................... appends s2 to s1*/  
....................   
.................... char *strcat(char *s1, char *s2)  
.................... {  
....................    char *s;  
....................   
....................    for (s = s1; *s != '\0'; ++s);  
....................    while(*s2 != '\0')  
....................    {  
....................       *s = *s2;  
....................       ++s;  
....................       ++s2;  
....................    }  
....................   
....................    *s = '\0';  
....................    return(s1);  
.................... }  
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)  
.................... appends not more than n characters from s2 to s1*/  
....................   
.................... char *strncat(char *s1, char *s2, size_t n)  
.................... {  
....................    char *s;  
....................   
....................    for (s = s1; *s != '\0'; ++s);  
....................    while(*s2 != '\0' && 0<n)  
....................    {  
....................       *s = *s2;  
....................       ++s;  
....................       ++s2;  
....................       --n;  
....................    }  
....................   
....................    *s = '\0';  
....................    return(s1);  
.................... }  
....................   
.................... /***********************************************************/  
....................   
.................... /*comparison functions*/  
.................... /* standard template: signed int memcmp(void *s1, void *s2).  
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */  
....................   
.................... signed int memcmp(void * s1,char *s2,size_t n)  
.................... {  
.................... char *su1, su2;  
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)  
.................... {  
....................    if(*su1!=*su2)  
....................       return ((*su1<*su2)??1:+1);  
.................... }  
.................... return 0;  
.................... }  
.................... /* standard template: int strcmp(const char *s1, const char *s2).  
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */  
....................   
.................... signed int strcmp(char *s1, char *s2)  
.................... {  
....................    for (; *s1 == *s2; s1++, s2++)  
....................       if (*s1 == '\0')  
....................          return(0);  
....................    return((*s1 < *s2) ??-1: 1);  
.................... }  
.................... /* standard template: int strcoll(const char *s1, const char *s2).  
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */  
....................   
.................... signed int strcoll(char *s1, char *s2)  
.................... {  
....................    for (; *s1 == *s2; s1++, s2++)  
....................       if (*s1 == '\0')  
....................          return(0);  
....................    return((*s1 < *s2) ??-1: 1);  
.................... }  
....................   
.................... /* standard template:  
....................    int strncmp(const char *s1, const char *s2, size_t n).  
....................    Compares max of n characters (not following 0) from s1 to s2;  
....................    returns same as strcmp */  
....................   
.................... signed int strncmp(char *s1, char *s2, size_t n)  
.................... {  
....................    for (; n > 0; s1++, s2++, n--)  
....................       if (*s1 != *s2)  
....................          return((*s1 <*s2) ??-1: 1);  
....................       else if (*s1 == '\0')  
....................          return(0);  
....................    return(0);  
.................... }  
.................... /* standard template:  
....................    int strxfrm(const char *s1, const char *s2, size_t n).  
....................    transforms maximum of n characters from s2 and places them into s1*/  
.................... size_t strxfrm(char *s1, char *s2, size_t n)  
.................... {  
....................   char *s;  
....................   int n1;  
....................   n1=n;  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)  
....................      *s++ = *s2++;  
....................   for (; n > 0; n--)  
....................      *s++ = '\0';  
....................   
....................   return(n1);  
.................... }  
....................   
....................   
....................   
....................   
....................   
.................... /***********************************************************/  
.................... /*Search functions*/  
.................... /* standard template: void *memchr(const char *s, int c).  
....................    Finds first occurrence of c in n characters of s */  
....................   
.................... char *memchr(void *s,int c,size_t n)  
.................... {  
....................    char uc;  
....................    char *su;  
....................    uc=c;  
....................    for(su=s;0<n;++su,--n)  
....................       if(*su==uc)  
....................       return su;  
....................    return NULL;  
.................... }  
....................   
.................... /* standard template: char *strchr(const char *s, int c).  
....................    Finds first occurrence of c in s */  
....................   
.................... char *strchr(char *s, int c)  
.................... {  
....................    for (; *s != c; s++)  
....................       if (*s == '\0')  
....................          return(0);  
....................    return(s);  
.................... }  
.................... /* standard template:  
....................    size_t strcspn(const char *s1, const char *s2).  
....................    Computes length of max initial segment of s1 that  
....................    consists entirely of characters NOT from s2*/  
....................   
.................... int *strcspn(char *s1, char *s2)  
.................... {  
....................    char *sc1, *sc2;  
....................   
....................    for (sc1 = s1; *sc1 != 0; sc1++)  
....................       for (sc2 = s2; *sc2 != 0; sc2++)  
....................          if (*sc1 == *sc2)  
....................             return(sc1 - s1);  
....................    return(sc1 - s1);  
.................... }  
.................... /* standard template:  
....................    char *strpbrk(const char *s1, const char *s2).  
....................    Locates first occurence of any character from s2 in s1;  
....................    returns s1 if s2 is empty string */  
....................   
.................... char *strpbrk(char *s1, char *s2)  
.................... {  
....................    char *sc1, *sc2;  
....................   
....................    for (sc1 = s1; *sc1 != 0; sc1++)  
....................       for (sc2 = s2; *sc2 != 0; sc2++)  
....................          if (*sc1 == *sc2)  
....................             return(sc1);  
....................    return(0);  
.................... }  
....................   
....................   
.................... /* standard template: char *strrchr(const char *s, int c).  
....................    Finds last occurrence of c in s */  
....................   
.................... char *strrchr(char *s, int c)  
.................... {  
....................    char *p;  
....................   
....................    for (p = 0; ; s++)  
....................    {  
....................       if (*s == c)  
....................          p = s;  
....................       if (*s == '\0')  
....................          return(p);  
....................    }  
.................... }  
.................... /* computes length of max initial segment of s1 consisting  
....................    entirely of characters from s2 */  
....................   
.................... int *strspn(char *s1, char *s2)  
.................... {  
....................    char *sc1, *sc2;  
....................   
....................    for (sc1 = s1; *sc1 != 0; sc1++)  
....................       for (sc2 = s2; ; sc2++)  
.................... 	 if (*sc2 == '\0')  
.................... 	    return(sc1 - s1);  
....................          else if (*sc1 == *sc2)  
....................             break;  
....................    return(sc1 - s1);  
.................... }  
.................... /* standard template:  
....................    char *strstr(const char *s1, const char *s2);  
....................    Locates first occurence of character sequence s2 in s1;  
....................    returns 0 if s2 is empty string  
....................   
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the  
....................    file to use the faster algorithm */  
.................... char *strstr(char *s1, char *s2)  
.................... {  
.................... 	char *s, *t;  
....................   
....................    #ifdef FASTER_BUT_MORE_ROM  
....................    if (*s2 == '\0')  
....................          return(s1);  
....................    #endif  
....................   
.................... 	while (*s1)  
....................    {  
....................       for(s = s1, t = s2; *t && *s == *t; ++s, ++t);  
....................   
.................... 		if (*t == '\0')  
.................... 			return s1;  
....................       ++s1;  
....................       #ifdef FASTER_BUT_MORE_ROM  
....................          while(*s1 != '\0' && *s1 != *s2)  
....................             ++s1;  
....................       #endif  
.................... 	}  
.................... 	return 0;  
.................... }  
....................   
.................... /* standard template: char *strtok(char *s1, const char *s2).  
....................   
....................    Finds next token in s1 delimited by a character from separator  
....................    string s2 (which can be different from call to call).  First call  
....................    starts at beginning of s1 searching for first character NOT  
....................    contained in s2; returns 0 if none is found.  
....................    If one is found, it is the start of first token (return value).  
....................    Function then searches from there for a character contained in s2.  
....................    If none is found, current token extends to end of s1, and subsequent  
....................    searches for a token will return 0.  If one is found, it is  
....................    overwritten by '\0', which terminates current token.  Function saves  
....................    pointer to following character from which next search will start.  
....................    Each subsequent call, with 0 as first argument, starts searching  
....................    from saved pointer */  
....................   
.................... char *strtok(char *s1, char *s2)  
.................... {  
....................    char *beg, *end;  
....................    static char *save;  
*
02C1:  CLRF   20
02C2:  MOVLW  81
02C3:  BSF    03.5
02C4:  MOVWF  19
02C5:  MOVLW  26
02C6:  MOVWF  18
02C7:  MOVLW  90
02C8:  BCF    03.5
02C9:  MOVWF  18
....................   
....................    beg = (s1)??s1: save;  
....................    beg += strspn(beg, s2);  
....................    if (*beg == '\0')  
....................    {  
....................       *save = ' ';  
....................       return(0);  
....................    }  
....................    end = strpbrk(beg, s2);  
....................    if (*end != '\0')  
....................    {  
....................       *end = '\0';  
....................       end++;  
....................    }  
....................    save = end;  
....................    return(beg);  
.................... }  
....................   
.................... /*****************************************************************/  
.................... /*Miscellaneous functions*/  
.................... /* standard template  
.................... maps error number in errnum to an error message string  
.................... Returns: Pointer to string  
.................... */  
.................... #ifdef _ERRNO  
.................... char * strerror(int errnum)  
.................... {  
.................... char s[15];  
.................... switch( errnum)  
.................... {  
.................... case 0:  
....................    strcpy(s,"no errors");  
....................    return s;  
.................... case EDOM :  
....................    strcpy(s,"domain error");  
....................    return s;  
.................... case ERANGE:  
....................    strcpy(s,"range error");  
....................    return s;  
.................... }  
.................... }  
.................... #ENDIF  
.................... /* standard template: size_t strlen(const char *s).  
....................    Computes length of s1 (preceding terminating 0) */  
....................   
.................... int *strlen(char *s)  
.................... {  
....................    char *sc;  
....................   
....................    for (sc = s; *sc != 0; sc++);  
....................    return(sc - s);  
.................... }  
....................   
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).  
....................    Compares s1 to s2 ignoring case (upper vs. lower) */  
....................   
.................... signed int stricmp(char *s1, char *s2)  
.................... {  
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32));  
....................     s1++, s2++)  
....................     if (*s1 == '\0')  
....................        return(0);  
....................  return((*s1 < *s2) ??-1: 1);  
.................... }  
....................   
....................   
.................... /* standard template: char *strlwr(char *s).  
....................    Replaces uppercase letters by lowercase;  
....................    returns pointer to new string s */  
....................   
.................... char *strlwr(char *s)  
.................... {  
....................    char *p;  
....................   
....................    for (p = s; *p != '\0'; p++)  
....................       if (*p >= 'A' && *p <='Z')  
....................          *p += 'a' - 'A';  
....................    return(s);  
.................... }  
....................   
....................   
.................... /************************************************************/  
....................   
....................   
.................... #endif  
....................  
.................... #ifndef getc  
.................... #define getc getch  
.................... #define getchar getch  
.................... #define puts(s) {printf(s); putchar(13); putchar(10);}  
.................... #define putc putchar  
.................... #endif  
.................... /* maps error number to an error message. Writes a sequence of characters to  
.................... stderr stream thus: if s is not null then string pointed to by s follwed by  
.................... a colon (:) and a space and the appropriate error message returned by strerror  
.................... function with argument errno  
....................   
.................... Returns: no value  
.................... */  
....................   
.................... #ifdef _ERRNO  
.................... void perror(char *s)  
.................... {  
....................   if(s)  
....................   fprintf(STDERR,"%s: ",s);  
....................   fprintf(STDERR,"%s\r\n",strerror(errno));  
.................... }  
.................... #endif  
.................... #endif  
....................  
.................... #include<string.h> 
....................  ////////////////////////////////////////////////////////////////////////////  
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////  
.................... //// This source code may only be used by licensed users of the CCS C   ////  
.................... //// compiler.  This source code may only be distributed to other       ////  
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////  
.................... //// or distribution is permitted without written permission.           ////  
.................... //// Derivative programs created using this software in object code     ////  
.................... //// form are not restricted in any way.                                ////  
.................... ////////////////////////////////////////////////////////////////////////////  
....................   
.................... #ifndef _STRING  
.................... #define _STRING  
.................... #include <stddef.h>  
.................... #include <ctype.h>  
....................   
....................   
....................   
.................... //////////////////////////////////////////////  
.................... //// Uncomment the following define to    ////  
.................... //// allow some functions to use a        ////  
.................... //// quicker algorithm, but use more ROM  ////  
.................... ////                                      ////  
.................... //// #define FASTER_BUT_MORE_ROM          ////  
.................... //////////////////////////////////////////////  
....................   
....................   
....................   
.................... /*Copying functions*/  
.................... /* standard template:  
....................    void *memmove(void *s1, void *s2, size_t n).  
....................    Copies max of n characters safely (not following ending '\0')  
....................    from s2 in s1; if s2 has less than n characters, appends 0 */  
....................   
.................... char *memmove(void *s1,char *s2,size_t n)  
.................... {  
....................    char *sc1;  
....................    char *sc2;  
....................    sc1=s1;  
....................    sc2=s2;  
....................    if(sc2<sc1 && sc1 <sc2 +n)  
....................       for(sc1+=n,sc2+=n;0<n;--n)  
....................          *--sc1=*--sc2;  
....................    else  
....................       for(;0<n;--n)  
....................          *sc1++=*sc2++;  
....................   return s1;  
....................   }  
.................... /*    Standard template: char *strcpy(char *s1, const char *s2)  
.................... copies the string s2 including the null character to s1*/  
....................   
.................... char *strcpy(char *s1, char *s2)  
.................... {  
....................   char *s;  
....................   
....................   for (s = s1; *s2 != 0; s++, s2++)  
.................... 	  *s = *s2;  
....................   return(s1);  
.................... }  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved?? 
....................    Standard template: char *strcpy(char *s1, const char *s2)  
....................    copies the string s2 including the null character to s1*/  
....................   
.................... char *strcopy(char *s1, char *s2)  
.................... {  
....................   char *s;  
....................   
....................   for (s = s1; *s2 != 0; s++, s2++)  
.................... 	  *s = *s2;  
....................   return(s1);  
.................... }  
....................   
.................... /* standard template:  
....................    char *strncpy(char *s1, const char *s2, size_t n).  
....................    Copies max of n characters (not following ending '\0')  
....................    from s2 in s1; if s2 has less than n characters, appends 0 */  
....................   
.................... char *strncpy(char *s1, char *s2, size_t n)  
.................... {  
....................   char *s;  
....................   
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)  
....................      *s++ = *s2++;  
....................   for (; n > 0; n--)  
....................      *s++ = '\0';  
....................   
....................   return(s1);  
.................... }  
.................... /***********************************************************/  
....................   
.................... /*concatenation functions*/  
.................... /* standard template: char *strcat(char *s1, const char *s2)  
.................... appends s2 to s1*/  
....................   
.................... char *strcat(char *s1, char *s2)  
.................... {  
....................    char *s;  
....................   
....................    for (s = s1; *s != '\0'; ++s);  
....................    while(*s2 != '\0')  
....................    {  
....................       *s = *s2;  
....................       ++s;  
....................       ++s2;  
....................    }  
....................   
....................    *s = '\0';  
....................    return(s1);  
.................... }  
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)  
.................... appends not more than n characters from s2 to s1*/  
....................   
.................... char *strncat(char *s1, char *s2, size_t n)  
.................... {  
....................    char *s;  
....................   
....................    for (s = s1; *s != '\0'; ++s);  
....................    while(*s2 != '\0' && 0<n)  
....................    {  
....................       *s = *s2;  
....................       ++s;  
....................       ++s2;  
....................       --n;  
....................    }  
....................   
....................    *s = '\0';  
....................    return(s1);  
.................... }  
....................   
.................... /***********************************************************/  
....................   
.................... /*comparison functions*/  
.................... /* standard template: signed int memcmp(void *s1, void *s2).  
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */  
....................   
.................... signed int memcmp(void * s1,char *s2,size_t n)  
.................... {  
.................... char *su1, su2;  
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)  
.................... {  
....................    if(*su1!=*su2)  
....................       return ((*su1<*su2)??1:+1);  
.................... }  
.................... return 0;  
.................... }  
.................... /* standard template: int strcmp(const char *s1, const char *s2).  
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */  
....................   
.................... signed int strcmp(char *s1, char *s2)  
.................... {  
....................    for (; *s1 == *s2; s1++, s2++)  
....................       if (*s1 == '\0')  
....................          return(0);  
....................    return((*s1 < *s2) ??-1: 1);  
.................... }  
.................... /* standard template: int strcoll(const char *s1, const char *s2).  
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */  
....................   
.................... signed int strcoll(char *s1, char *s2)  
.................... {  
....................    for (; *s1 == *s2; s1++, s2++)  
....................       if (*s1 == '\0')  
....................          return(0);  
....................    return((*s1 < *s2) ??-1: 1);  
.................... }  
....................   
.................... /* standard template:  
....................    int strncmp(const char *s1, const char *s2, size_t n).  
....................    Compares max of n characters (not following 0) from s1 to s2;  
....................    returns same as strcmp */  
....................   
.................... signed int strncmp(char *s1, char *s2, size_t n)  
.................... {  
....................    for (; n > 0; s1++, s2++, n--)  
....................       if (*s1 != *s2)  
....................          return((*s1 <*s2) ??-1: 1);  
....................       else if (*s1 == '\0')  
....................          return(0);  
....................    return(0);  
.................... }  
.................... /* standard template:  
....................    int strxfrm(const char *s1, const char *s2, size_t n).  
....................    transforms maximum of n characters from s2 and places them into s1*/  
.................... size_t strxfrm(char *s1, char *s2, size_t n)  
.................... {  
....................   char *s;  
....................   int n1;  
....................   n1=n;  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)  
....................      *s++ = *s2++;  
....................   for (; n > 0; n--)  
....................      *s++ = '\0';  
....................   
....................   return(n1);  
.................... }  
....................   
....................   
....................   
....................   
....................   
.................... /***********************************************************/  
.................... /*Search functions*/  
.................... /* standard template: void *memchr(const char *s, int c).  
....................    Finds first occurrence of c in n characters of s */  
....................   
.................... char *memchr(void *s,int c,size_t n)  
.................... {  
....................    char uc;  
....................    char *su;  
....................    uc=c;  
....................    for(su=s;0<n;++su,--n)  
....................       if(*su==uc)  
....................       return su;  
....................    return NULL;  
.................... }  
....................   
.................... /* standard template: char *strchr(const char *s, int c).  
....................    Finds first occurrence of c in s */  
....................   
.................... char *strchr(char *s, int c)  
.................... {  
....................    for (; *s != c; s++)  
....................       if (*s == '\0')  
....................          return(0);  
....................    return(s);  
.................... }  
.................... /* standard template:  
....................    size_t strcspn(const char *s1, const char *s2).  
....................    Computes length of max initial segment of s1 that  
....................    consists entirely of characters NOT from s2*/  
....................   
.................... int *strcspn(char *s1, char *s2)  
.................... {  
....................    char *sc1, *sc2;  
....................   
....................    for (sc1 = s1; *sc1 != 0; sc1++)  
....................       for (sc2 = s2; *sc2 != 0; sc2++)  
....................          if (*sc1 == *sc2)  
....................             return(sc1 - s1);  
....................    return(sc1 - s1);  
.................... }  
.................... /* standard template:  
....................    char *strpbrk(const char *s1, const char *s2).  
....................    Locates first occurence of any character from s2 in s1;  
....................    returns s1 if s2 is empty string */  
....................   
.................... char *strpbrk(char *s1, char *s2)  
.................... {  
....................    char *sc1, *sc2;  
....................   
....................    for (sc1 = s1; *sc1 != 0; sc1++)  
....................       for (sc2 = s2; *sc2 != 0; sc2++)  
....................          if (*sc1 == *sc2)  
....................             return(sc1);  
....................    return(0);  
.................... }  
....................   
....................   
.................... /* standard template: char *strrchr(const char *s, int c).  
....................    Finds last occurrence of c in s */  
....................   
.................... char *strrchr(char *s, int c)  
.................... {  
....................    char *p;  
....................   
....................    for (p = 0; ; s++)  
....................    {  
....................       if (*s == c)  
....................          p = s;  
....................       if (*s == '\0')  
....................          return(p);  
....................    }  
.................... }  
.................... /* computes length of max initial segment of s1 consisting  
....................    entirely of characters from s2 */  
....................   
.................... int *strspn(char *s1, char *s2)  
.................... {  
....................    char *sc1, *sc2;  
....................   
....................    for (sc1 = s1; *sc1 != 0; sc1++)  
....................       for (sc2 = s2; ; sc2++)  
.................... 	 if (*sc2 == '\0')  
.................... 	    return(sc1 - s1);  
....................          else if (*sc1 == *sc2)  
....................             break;  
....................    return(sc1 - s1);  
.................... }  
.................... /* standard template:  
....................    char *strstr(const char *s1, const char *s2);  
....................    Locates first occurence of character sequence s2 in s1;  
....................    returns 0 if s2 is empty string  
....................   
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the  
....................    file to use the faster algorithm */  
.................... char *strstr(char *s1, char *s2)  
.................... {  
.................... 	char *s, *t;  
....................   
....................    #ifdef FASTER_BUT_MORE_ROM  
....................    if (*s2 == '\0')  
....................          return(s1);  
....................    #endif  
....................   
.................... 	while (*s1)  
....................    {  
....................       for(s = s1, t = s2; *t && *s == *t; ++s, ++t);  
....................   
.................... 		if (*t == '\0')  
.................... 			return s1;  
....................       ++s1;  
....................       #ifdef FASTER_BUT_MORE_ROM  
....................          while(*s1 != '\0' && *s1 != *s2)  
....................             ++s1;  
....................       #endif  
.................... 	}  
.................... 	return 0;  
.................... }  
....................   
.................... /* standard template: char *strtok(char *s1, const char *s2).  
....................   
....................    Finds next token in s1 delimited by a character from separator  
....................    string s2 (which can be different from call to call).  First call  
....................    starts at beginning of s1 searching for first character NOT  
....................    contained in s2; returns 0 if none is found.  
....................    If one is found, it is the start of first token (return value).  
....................    Function then searches from there for a character contained in s2.  
....................    If none is found, current token extends to end of s1, and subsequent  
....................    searches for a token will return 0.  If one is found, it is  
....................    overwritten by '\0', which terminates current token.  Function saves  
....................    pointer to following character from which next search will start.  
....................    Each subsequent call, with 0 as first argument, starts searching  
....................    from saved pointer */  
....................   
.................... char *strtok(char *s1, char *s2)  
.................... {  
....................    char *beg, *end;  
....................    static char *save;  
....................   
....................    beg = (s1)??s1: save;  
....................    beg += strspn(beg, s2);  
....................    if (*beg == '\0')  
....................    {  
....................       *save = ' ';  
....................       return(0);  
....................    }  
....................    end = strpbrk(beg, s2);  
....................    if (*end != '\0')  
....................    {  
....................       *end = '\0';  
....................       end++;  
....................    }  
....................    save = end;  
....................    return(beg);  
.................... }  
....................   
.................... /*****************************************************************/  
.................... /*Miscellaneous functions*/  
.................... /* standard template  
.................... maps error number in errnum to an error message string  
.................... Returns: Pointer to string  
.................... */  
.................... #ifdef _ERRNO  
.................... char * strerror(int errnum)  
.................... {  
.................... char s[15];  
.................... switch( errnum)  
.................... {  
.................... case 0:  
....................    strcpy(s,"no errors");  
....................    return s;  
.................... case EDOM :  
....................    strcpy(s,"domain error");  
....................    return s;  
.................... case ERANGE:  
....................    strcpy(s,"range error");  
....................    return s;  
.................... }  
.................... }  
.................... #ENDIF  
.................... /* standard template: size_t strlen(const char *s).  
....................    Computes length of s1 (preceding terminating 0) */  
....................   
.................... int *strlen(char *s)  
.................... {  
....................    char *sc;  
....................   
....................    for (sc = s; *sc != 0; sc++);  
....................    return(sc - s);  
.................... }  
....................   
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).  
....................    Compares s1 to s2 ignoring case (upper vs. lower) */  
....................   
.................... signed int stricmp(char *s1, char *s2)  
.................... {  
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32));  
....................     s1++, s2++)  
....................     if (*s1 == '\0')  
....................        return(0);  
....................  return((*s1 < *s2) ??-1: 1);  
.................... }  
....................   
....................   
.................... /* standard template: char *strlwr(char *s).  
....................    Replaces uppercase letters by lowercase;  
....................    returns pointer to new string s */  
....................   
.................... char *strlwr(char *s)  
.................... {  
....................    char *p;  
....................   
....................    for (p = s; *p != '\0'; p++)  
....................       if (*p >= 'A' && *p <='Z')  
....................          *p += 'a' - 'A';  
....................    return(s);  
.................... }  
....................   
....................   
.................... /************************************************************/  
....................   
....................   
.................... #endif  
....................  
.................... #include<math.h> 
....................  ////////////////////////////////////////////////////////////////////////////  
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////  
.................... //// This source code may only be used by licensed users of the CCS C   ////  
.................... //// compiler.  This source code may only be distributed to other       ////  
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////  
.................... //// or distribution is permitted without written permission.           ////  
.................... //// Derivative programs created using this software in object code     ////  
.................... //// form are not restricted in any way.                                ////  
.................... ////////////////////////////////////////////////////////////////////////////  
.................... ////                                                                    ////  
.................... //// History:                                                           ////  
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////  
.................... ////                 The code now is small, much faster,                ////  
.................... ////                 and more accurate.                                 ////  
.................... ////                                                                    ////  
.................... ////////////////////////////////////////////////////////////////////////////  
....................   
.................... #ifndef MATH_H  
.................... #define MATH_H  
....................   
....................   
.................... #undef  PI  
.................... #define PI     3.141592654  
....................   
....................   
.................... #define SQRT2  1.41421356  
....................   
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};  
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};  
....................   
.................... ///////////////////////////// Round Functions //////////////////////////////  
....................   
.................... float CEIL_FLOOR(float x, int n)  
.................... {  
....................    float y, res;  
....................    long l;  
....................    int1 s;  
....................   
....................    s = 0;  
....................    y = x;  
....................   
....................    if (x < 0)  
....................    {  
....................       s = 1;  
....................       y = -y;  
....................    }  
....................   
....................    if (y <= 32768.0)  
....................   res = (float)(long)y;  
....................   
....................  else if (y < 10000000.0)  
....................    {  
....................   l = (long)(y/32768.0);  
....................       y = 32768.0*(y/32768.0 - (float)l);  
....................   res = 32768.0*(float)l;  
....................   res += (float)(long)y;  
....................  }  
....................   
....................  else  
....................   res = y;  
....................   
....................  y = y - (float)(long)y;  
....................   
....................  if (s)  
....................   res = -res;  
....................   
....................  if (y != 0)  
....................  {  
....................   if (s == 1 && n == 0)  
....................    res -= 1.0;  
....................   
....................   if (s == 0 && n == 1)  
....................    res += 1.0;  
....................  }  
....................  if (x == 0)  
....................     res = 0;  
....................   
....................  return (res);  
.................... }  
....................   
.................... ////////////////////////////////////////////////////////////////////////////  
.................... //	float floor(float x)  
.................... ////////////////////////////////////////////////////////////////////////////  
.................... // Description : rounds down the number x.  
.................... // Date : N/A  
.................... //  
.................... float floor(float x)  
.................... {  
....................    return CEIL_FLOOR(x, 0);  
.................... }  
....................   
.................... ////////////////////////////////////////////////////////////////////////////  
.................... //	float ceil(float x)  
.................... ////////////////////////////////////////////////////////////////////////////  
.................... // Description : rounds up the number x.  
.................... // Date : N/A  
.................... //  
.................... float ceil(float x)  
.................... {  
....................    return CEIL_FLOOR(x, 1);  
.................... }  
....................   
....................  ////////////////////////////////////////////////////////////////////////////  
.................... //	float fabs(float x)  
.................... ////////////////////////////////////////////////////////////////////////////  
.................... // Description : Computes the absolute value of floating point number x  
.................... // Returns : returns the absolute value of x  
.................... // Date : N/A  
.................... //  
.................... #define fabs abs  
....................   
.................... ////////////////////////////////////////////////////////////////////////////  
.................... //	float fmod(float x)  
.................... ////////////////////////////////////////////////////////////////////////////  
.................... // Description : Computes the floating point remainder of x/y  
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y  
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the  
.................... // magnitude of y. If y is zero then a domain error occurs.  
.................... // Date : N/A  
.................... //  
....................   
.................... float fmod(float x,float y)  
.................... {  
....................    float i;  
....................    if (y!=0.0)  
....................    {  
....................       i=(x/y < 0.0)??ceil(x/y): floor(x/y);  
....................       return(x-(i*y));  
....................    }  
....................    else  
....................    {  
....................    #ifdef _ERRNO  
....................    {  
....................       errno=EDOM;  
....................    }  
....................    #endif  
....................    }  
.................... }  
....................   
.................... //////////////////// Exponential and logarithmic functions ////////////////////  
....................   
.................... #define LN2 0.6931471806  
....................   
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,  
....................                      0.0554965651,  0.240227138,  0.693147172};  
....................   
.................... ////////////////////////////////////////////////////////////////////////////  
.................... //	float exp(float x)  
.................... ////////////////////////////////////////////////////////////////////////////  
.................... // Description : returns the value (e^x)  
.................... // Date : N/A  
.................... //  
.................... float exp(float x)  
.................... {  
....................    float y, res, r;  
....................    signed int n;  
....................    int1 s;  
....................    #ifdef _ERRNO  
....................    if(x > 88.722838)  
....................    {  
....................       errno=ERANGE;  
....................       return(0);  
....................    }  
....................    #endif  
....................    n = (signed long)(x/LN2);  
....................    s = 0;  
....................    y = x;  
....................   
....................    if (x < 0)  
....................    {  
....................       s = 1;  
....................       n = -n;  
....................       y = -y;  
....................    }  
....................   
....................    res = 0.0;  
....................    *(&res) = n + 0x7F;  
....................   
....................    y = y/LN2 - (float)n;  
....................   
....................    r = pe[0]*y + pe[1];  
....................    r = r*y + pe[2];  
....................    r = r*y + pe[3];  
....................    r = r*y + pe[4];  
....................    r = r*y + pe[5];  
....................   
....................    res = res*(1.0 + y*r);  
....................   
....................    if (s)  
....................       res = 1.0/res;  
....................    return(res);  
.................... }  
....................   
.................... /************************************************************/  
....................   
.................... float const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189};  
.................... float const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943};  
....................   
.................... ////////////////////////////////////////////////////////////////////////////  
.................... //	float log(float x)  
.................... ////////////////////////////////////////////////////////////////////////////  
.................... // Description : returns the the natural log of x  
.................... // Date : N/A  
.................... //  
.................... float log(float x)  
.................... {  
....................    float y, res, r, y2;  
....................    signed n;  
....................    #ifdef _ERRNO  
....................    if(x <0)  
....................    {  
....................       errno=EDOM;  
....................    }  
....................    if(x ==0)  
....................    {  
....................       errno=ERANGE;  
....................       return(0);  
....................    }  
....................    #endif  
....................    y = x;  
....................   
....................    if (y != 1.0)  
....................    {  
....................       *(&y) = 0x7E;  
....................   
....................       y = (y - 1.0)/(y + 1.0);  
....................   
....................       y2=y*y;  
....................   
....................       res = pl[0]*y2 + pl[1];  
....................       res = res*y2 + pl[2];  
....................       res = res*y2 + pl[3];  
....................   
....................       r = ql[0]*y2 + ql[1];  
....................       r = r*y2 + ql[2];  
....................       r = r*y2 + ql[3];  
....................   
....................       res = y*res/r;  
....................   
....................       n = *(&x) - 0x7E;  
....................   
....................       if (n<0)  
....................          r = -(float)-n;  
....................       else  
....................          r = (float)n;  
....................   
....................       res += r*LN2;  
....................    }  
....................   
....................    else  
....................       res = 0.0;  
....................   
....................    return(res);  
.................... }  
....................   
.................... #define LN10 2.30258509  
....................   
.................... ////////////////////////////////////////////////////////////////////////////  
.................... //	float log10(float x)  
.................... ////////////////////////////////////////////////////////////////////////////  
.................... // Description : returns the the log base 10 of x  
.................... // Date : N/A  
.................... //  
.................... float log10(float x)  
.................... {  
....................    float r;  
....................   
....................    r = log(x);  
....................    r = r/LN10;  
....................    return(r);  
.................... }  
....................   
.................... ////////////////////////////////////////////////////////////////////////////  
.................... //	float modf(float x)  
.................... ////////////////////////////////////////////////////////////////////////////  
.................... // Description :breaks the argument value int integral and fractional parts,  
.................... // ach of which have the same sign as the argument.  It stores the integral part  
.................... // as a float in the object pointed to by the iptr  
.................... // Returns : returns the signed fractional part of value.  
.................... // Date : N/A  
.................... //  
....................   
.................... float modf(float value,float *iptr)  
.................... {  
....................    *iptr=(value < 0.0)??ceil(value): floor(value);  
....................    return(value - *iptr);  
.................... }  
....................   
....................   
.................... ////////////////////////////////////////////////////////////////////////////  
.................... //	float pwr(float x,float y)  
.................... ////////////////////////////////////////////////////////////////////////////  
.................... // Description : returns the value (x^y)  
.................... // Date : N/A  
.................... //  
.................... float pwr(float x,float y)  
.................... {  
....................    if(x>=0)  
....................      return(  exp(y*log(x)) );  
....................    else  
....................      return(  -exp(y*log(-x)) );  
.................... }  
....................   
....................   
.................... //////////////////// Power functions ////////////////////  
....................   
.................... ////////////////////////////////////////////////////////////////////////////  
.................... //	float pow(float x,float y)  
.................... ////////////////////////////////////////////////////////////////////////////  
.................... // Description : returns the value (x^y)  
.................... // Date : N/A  
.................... //  
.................... float pow(float x,float y)  
.................... {  
....................    if(x>=0)  
....................      return(  exp(y*log(x)) );  
....................    else  
....................      return(  -exp(y*log(-x)) );  
.................... }  
....................   
.................... ////////////////////////////////////////////////////////////////////////////  
.................... //	float sqrt(float x)  
.................... ////////////////////////////////////////////////////////////////////////////  
.................... // Description : returns the square root of x  
.................... // Date : N/A  
.................... //  
.................... float sqrt(float x)  
.................... {  
....................    float y, res;  
....................    BYTE *p;  
....................   
....................    #ifdef _ERRNO  
....................    if(x < 0)  
....................    {  
....................       errno=EDOM;  
....................    }  
....................    #endif  
....................   
....................    if( x<=0.0)  
....................       return(0.0);  
....................   
....................    y=x;  
....................    p=&y;  
....................    (*p)=(BYTE)((((int16)(*p)) + 127) >> 1);  
....................   
....................    do {  
....................       res=y;  
....................       y+=(x/y);  
....................       (*p)--;  
....................    } while(res != y);  
....................   
....................    return(res);  
.................... }  
....................   
....................   
....................   
.................... ////////////////////////////// Trig Functions //////////////////////////////  
.................... #undef PI_DIV_BY_TWO  
.................... #define PI_DIV_BY_TWO	1.570796326794896  
.................... #undef TWOBYPI  
.................... #define TWOBYPI 			0.6366197724  
.................... ////////////////////////////////////////////////////////////////////////////  
.................... //	float cos(float x)  
.................... ////////////////////////////////////////////////////////////////////////////  
.................... // Description : returns the cosine value of the angle x, which is in radian  
.................... // Date : 9/20/2001  
.................... //  
.................... float cos(float x)  
.................... {  
.................... 	float y, t, t2 = 1.0;  
.................... 	int quad, i;  
.................... 	float frac;  
.................... 	float p[4] = {  
.................... 		-0.499999993585,  
.................... 		 0.041666636258,  
.................... 		-0.0013888361399,  
.................... 		 0.00002476016134  
.................... 	};  
....................   
.................... 	if (x < 0) x = -x;                  // absolute value of input  
....................   
.................... 	quad = (int)(x / PI_DIV_BY_TWO);    // quadrant  
.................... 	frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input  
.................... 	quad = quad % 4;                    // quadrant (0 to 3)  
....................   
.................... 	if (quad == 0 || quad == 2)  
.................... 		t = frac * PI_DIV_BY_TWO;  
.................... 	else if (quad == 1)  
.................... 		t = (1-frac) * PI_DIV_BY_TWO;  
.................... 	else // should be 3  
.................... 		t = (frac-1) * PI_DIV_BY_TWO;  
....................   
.................... 	y = 0.999999999781;  
.................... 	t = t * t;  
.................... 	for (i = 0; i <= 3; i++)  
.................... 	{  
.................... 		t2 = t2 * t;  
.................... 		y = y + p[i] * t2;  
.................... 	}  
....................   
.................... 	if (quad == 2 || quad == 1)  
.................... 		y = -y;  // correct sign  
....................   
.................... 	return (y);  
.................... }  
....................   
.................... ////////////////////////////////////////////////////////////////////////////  
.................... //	float sin(float x)  
.................... ////////////////////////////////////////////////////////////////////////////  
.................... // Description : returns the sine value of the angle x, which is in radian  
.................... // Date : 9/20/2001  
.................... //  
.................... float sin(float x)  
.................... {  
.................... 	return cos(x - PI_DIV_BY_TWO);  
.................... }  
....................   
.................... ////////////////////////////////////////////////////////////////////////////  
.................... //	float tan(float x)  
.................... ////////////////////////////////////////////////////////////////////////////  
.................... // Description : returns the tangent value of the angle x, which is in radian  
.................... // Date : 9/20/2001  
.................... //  
.................... float tan(float x)  
.................... {  
....................    float c, s;  
....................   
....................    c = cos(x);  
.................... 	if (c == 0.0)  
.................... 	   return (1.0e+36);  
....................   
....................    s = sin(x);  
....................    return(s/c);  
.................... }  
....................   
....................   
....................   
.................... float const pas[3] = {0.49559947, -4.6145309, 5.6036290};  
.................... float const qas[3] = {1.0000000,  -5.5484666, 5.6036290};  
....................   
.................... float ASIN_COS(float x, int n)  
.................... {  
....................    float y, res, r, y2;  
....................    int1 s;  
....................    #ifdef _ERRNO  
....................    if(x <-1 || x > 1)  
....................    {  
....................       errno=EDOM;  
....................    }  
....................    #endif  
....................    s = 0;  
....................    y = x;  
....................   
....................    if (x < 0)  
....................    {  
....................       s = 1;  
....................       y = -y;  
....................    }  
....................   
....................    if (y > 0.5)  
....................    {  
....................       y = sqrt((1.0 - y)/2.0);  
....................       n += 2;  
....................    }  
....................   
....................    y2=y*y;  
....................   
....................    res = pas[0]*y2 + pas[1];  
....................    res = res*y2 + pas[2];  
....................   
....................    r = qas[0]*y2 + qas[1];  
....................    r = r*y2 + qas[2];  
....................   
....................    res = y*res/r;  
....................   
....................    if (n & 2)     // |x| > 0.5  
....................       res = PI_DIV_BY_TWO - 2.0*res;  
....................    if (s)  
....................       res = -res;  
....................    if (n & 1)           // take arccos  
....................       res = PI_DIV_BY_TWO - res;  
....................   
....................    return(res);  
.................... }  
....................   
....................   
.................... ////////////////////////////////////////////////////////////////////////////  
.................... //	float asin(float x)  
.................... ////////////////////////////////////////////////////////////////////////////  
.................... // Description : returns the arcsine value of the value x.  
.................... // Date : N/A  
.................... //  
.................... float asin(float x)  
.................... {  
....................    float r;  
....................   
....................    r = ASIN_COS(x, 0);  
....................    return(r);  
.................... }  
....................   
....................   
.................... ////////////////////////////////////////////////////////////////////////////  
.................... //	float acos(float x)  
.................... ////////////////////////////////////////////////////////////////////////////  
.................... // Description : returns the arccosine value of the value x.  
.................... // Date : N/A  
.................... //  
.................... float acos(float x)  
.................... {  
....................    float r;  
....................   
....................    r = ASIN_COS(x, 1);  
....................    return(r);  
.................... }  
....................   
.................... float const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};  
.................... float const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};  
....................   
.................... ////////////////////////////////////////////////////////////////////////////  
.................... //	float atan(float x)  
.................... ////////////////////////////////////////////////////////////////////////////  
.................... // Description : returns the arctangent value of the value x.  
.................... // Date : N/A  
.................... //  
.................... float atan(float x)  
.................... {  
....................    float y, res, r;  
....................    int1 s, flag;  
....................   
....................    s = 0;  
....................    flag = 0;  
....................    y = x;  
....................   
....................    if (x < 0)  
....................    {  
....................       s = 1;  
....................       y = -y;  
....................    }  
....................   
....................    if (y > 1.0)  
....................    {  
....................       y = 1.0/y;  
....................       flag = 1;  
....................    }  
....................   
....................    res = pat[0]*y*y + pat[1];  
....................    res = res*y*y + pat[2];  
....................    res = res*y*y + pat[3];  
....................   
....................    r = qat[0]*y*y + qat[1];  
....................    r = r*y*y + qat[2];  
....................    r = r*y*y + qat[3];  
....................   
....................    res = y*res/r;  
....................   
....................   
....................    if (flag)                              // for |x| > 1  
....................       res = PI_DIV_BY_TWO - res;  
....................    if (s)  
....................       res = -res;  
....................   
....................    return(res);  
.................... }  
....................   
.................... /////////////////////////////////////////////////////////////////////////////  
.................... //	float atan2(float y, float x)  
.................... /////////////////////////////////////////////////////////////////////////////  
.................... // Description :computes the principal value of arc tangent of y/x, using the  
.................... // signs of both the arguments to determine the quadrant of the return value  
.................... // Returns : returns the arc tangent of y/x.  
.................... // Date : N/A  
.................... //  
....................   
....................   
.................... float atan2(float y,float x)  
.................... {  
....................    float z;  
....................    int1 sign;  
....................    int quad;  
....................    sign=0;  
....................    quad=0; //quadrant  
....................    quad=((y<=0.0)??(x<=0.0)??:4):((x<0.0)??:1));  
....................    if(y<0.0)  
....................    {  
....................       sign=1;  
....................       y=-y;  
....................    }  
....................    if(x<0.0)  
....................    {  
....................       x=-x;  
....................    }  
....................    if (x==0.0)  
....................    {  
....................       if(y==0.0)  
....................       {  
....................       #ifdef _ERRNO  
....................       {  
....................          errno=EDOM;  
....................       }  
....................       #endif  
....................       }  
....................       else  
....................       {  
....................          if(sign)  
....................          {  
....................          return (-(PI_DIV_BY_TWO));  
....................          }  
....................          else  
....................          {  
....................          return (PI_DIV_BY_TWO);  
....................          }  
....................       }  
....................    }  
....................    else  
....................    {  
....................       z=y/x;  
....................       switch(quad)  
....................       {  
....................          case 1:  
....................          {  
....................             return atan(z);  
....................             break;  
....................          }  
....................          case 2:  
....................          {  
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122  
....................             return (PI-atan(z));  
....................             break;  
....................          }  
....................          case 3:  
....................          {  
....................             return (atan(z)-PI);  
....................             break;  
....................          }  
....................          case 4:  
....................          {  
....................             return (-atan(z));  
....................             break;  
....................          }  
....................       }  
....................    }  
.................... }  
....................   
.................... //////////////////// Hyperbolic functions ////////////////////  
....................   
.................... ////////////////////////////////////////////////////////////////////////////  
.................... //	float cosh(float x)  
.................... ////////////////////////////////////////////////////////////////////////////  
.................... // Description : Computes the hyperbolic cosine value of x  
.................... // Returns : returns the hyperbolic cosine value of x  
.................... // Date : N/A  
.................... //  
....................   
.................... float cosh(float x)  
.................... {  
....................    return ((exp(x)+exp(-x))/2);  
.................... }  
....................   
.................... ////////////////////////////////////////////////////////////////////////////  
.................... //	float sinh(float x)  
.................... ////////////////////////////////////////////////////////////////////////////  
.................... // Description : Computes the hyperbolic sine value of x  
.................... // Returns : returns the hyperbolic sine value of x  
.................... // Date : N/A  
.................... //  
....................   
.................... float sinh(float x)  
.................... {  
....................   
....................    return ((exp(x) - exp(-x))/2);  
.................... }  
....................   
.................... ////////////////////////////////////////////////////////////////////////////  
.................... //	float tanh(float x)  
.................... ////////////////////////////////////////////////////////////////////////////  
.................... // Description : Computes the hyperbolic tangent value of x  
.................... // Returns : returns the hyperbolic tangent value of x  
.................... // Date : N/A  
.................... //  
....................   
.................... float tanh(float x)  
.................... {  
....................    return(sinh(x)/cosh(x));  
.................... }  
....................   
.................... ////////////////////////////////////////////////////////////////////////////  
.................... //	float frexp(float x, signed int *exp)  
.................... ////////////////////////////////////////////////////////////////////////////  
.................... // Description : breaks a floating point number into a normalized fraction and an integral  
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.  
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval  
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,  
.................... // both parts of the result are zero.  
.................... // Date : N/A  
.................... //  
....................   
....................   
....................   
.................... #define LOG2 .30102999566398119521  
.................... float frexp(float x, signed int *exp)  
.................... {  
....................    float res;  
....................    int1 sign = 0;  
....................    if(x == 0.0)  
....................    {  
....................       *exp=0;  
....................       return (0.0);  
....................    }  
....................    if(x < 0.0)  
....................    {  
....................      x=-x;  
....................      sign=1;  
....................    }  
....................    if (x > 1.0)  
....................    {  
....................       *exp=(ceil(log10(x)/LOG2));  
....................       res=x/(pow(2, *exp));  
....................       if (res == 1)  
....................       {  
....................          *exp=*exp+1;  
....................           res=.5;  
....................       }  
....................    }  
....................    else  
....................    {  
....................       if(x < 0.5)  
....................       {  
....................          *exp=-1;  
....................          res=x*2;  
....................       }  
....................       else  
....................       {  
....................          *exp=0;  
....................           res=x;  
....................       }  
....................    }  
....................    if(sign)  
....................    {  
....................       res=-res;  
....................    }  
....................    return res;  
.................... }  
....................   
.................... //////////////////////////////////////////////////////////////////////////////  
.................... //	float ldexp(float x, signed int *exp)  
.................... //////////////////////////////////////////////////////////////////////////////  
.................... // Description : multiplies a floating point number by an integral power of 2.  
.................... // Returns : returns the value of x times 2 raised to the power exp.  
.................... // Date : N/A  
.................... //  
....................   
.................... float ldexp(float value, signed int exp)  
.................... {  
....................    return (value * pow(2,exp));  
.................... }  
.................... #endif  
....................  
....................   
.................... #use delay(clock = 20000000)  
*
0021:  MOVLW  28
0022:  MOVWF  04
0023:  MOVF   00,W
0024:  BTFSC  03.2
0025:  GOTO   033
0026:  MOVLW  06
0027:  MOVWF  78
0028:  CLRF   77
0029:  DECFSZ 77,F
002A:  GOTO   029
002B:  DECFSZ 78,F
002C:  GOTO   028
002D:  MOVLW  7B
002E:  MOVWF  77
002F:  DECFSZ 77,F
0030:  GOTO   02F
0031:  DECFSZ 00,F
0032:  GOTO   026
0033:  BCF    0A.3
0034:  BCF    0A.4
0035:  GOTO   302 (RETURN)
.................... #fuses HS,NOWDT,NOPROTECT,PUT,BROWNOUT,NOLVP  
.................... #define RS_BAUD		9600  
.................... #define RS_TX		PIN_C6  
.................... #define RS_RX		PIN_C7  
.................... #define RUN_LED		PIN_C0  
.................... #use rs232(BAUD = RS_BAUD , XMIT = RS_TX, RCV = RS_RX)  //rs232c設定  
....................   
....................   
....................   
.................... #byte port_a = 5  
.................... #byte port_b = 6  
.................... #byte port_c = 7  
.................... #byte port_d = 8  
.................... #byte port_e = 9  
....................   
....................   
....................   
.................... main()  
.................... {  
*
02B8:  CLRF   04
02B9:  MOVLW  1F
02BA:  ANDWF  03,F
02BB:  MOVLW  06
02BC:  BSF    03.5
02BD:  MOVWF  1F
02BE:  MOVLW  07
02BF:  BCF    03.5
02C0:  MOVWF  1F
.................... 	long int adc = 0;   
*
02CC:  CLRF   22
02CD:  CLRF   23
.................... 	float DDD = 0;  
02CE:  CLRF   24
02CF:  CLRF   25
02D0:  CLRF   26
02D1:  CLRF   27
.................... 	set_tris_a(0xFF);  
02D2:  MOVLW  FF
02D3:  BSF    03.5
02D4:  MOVWF  05
.................... 	set_tris_b(0xFF);  
02D5:  MOVWF  06
.................... 	set_tris_c(0x80);  
*
02CA:  MOVLW  FF
02CB:  MOVWF  21
*
02D6:  MOVLW  80
02D7:  MOVWF  07
02D8:  BCF    03.5
02D9:  MOVWF  21
.................... 	set_tris_d(0xFF);  
02DA:  MOVLW  FF
02DB:  BSF    03.5
02DC:  MOVWF  08
.................... 	set_tris_e(0xFF);  
02DD:  BSF    09.0
02DE:  BSF    09.1
02DF:  BSF    09.2
.................... 	  
.................... 	setup_adc_ports(ALL_ANALOG);  
02E0:  CLRF   1F
.................... 	setup_adc(ADC_CLOCK_INTERNAL);  
02E1:  BCF    03.5
02E2:  MOVF   1F,W
02E3:  ANDLW  38
02E4:  IORLW  C1
02E5:  MOVWF  1F
.................... 	printf("AD start\n");  
02E6:  CLRF   28
02E7:  MOVF   28,W
02E8:  CALL   004
02E9:  INCF   28,F
02EA:  MOVWF  77
02EB:  MOVF   77,W
02EC:  BTFSS  0C.4
02ED:  GOTO   2EC
02EE:  MOVWF  19
02EF:  MOVLW  09
02F0:  SUBWF  28,W
02F1:  BTFSS  03.2
02F2:  GOTO   2E7
.................... 	while(1)  
.................... 	{  
.................... 		set_adc_channel(7);  //7チャンネルを使用  
02F3:  MOVLW  38
02F4:  MOVWF  78
02F5:  MOVF   1F,W
02F6:  ANDLW  C7
02F7:  IORWF  78,W
02F8:  MOVWF  1F
.................... 		//delay_ms(1000);  
.................... 		output_high(PIN_C3);  
02F9:  BCF    21.3
02FA:  MOVF   21,W
02FB:  BSF    03.5
02FC:  MOVWF  07
02FD:  BCF    03.5
02FE:  BSF    07.3
.................... 		//adc = read_adc();  //A/D変換値の読み込み  
.................... 		//printf("\r%ld\n",adc);  
.................... 		//printf("A/D変換の値\r%ld\n",adc);  
.................... 		delay_ms(200);  
02FF:  MOVLW  C8
0300:  MOVWF  28
0301:  GOTO   021
.................... 		output_low(PIN_C3);  
0302:  BCF    21.3
0303:  MOVF   21,W
0304:  BSF    03.5
0305:  MOVWF  07
0306:  BCF    03.5
0307:  BCF    07.3
.................... 		adc = read_adc();  //A/D変換値の読み込み  
0308:  BSF    1F.2
0309:  BTFSC  1F.2
030A:  GOTO   309
030B:  MOVF   1E,W
030C:  CLRF   23
030D:  MOVWF  22
.................... 		DDD = adc * 0.048828;  
030E:  MOVF   23,W
030F:  MOVWF  29
0310:  MOVF   22,W
0311:  MOVWF  28
0312:  GOTO   036
0313:  MOVF   7A,W
0314:  MOVWF  2B
0315:  MOVF   79,W
0316:  MOVWF  2A
0317:  MOVF   78,W
0318:  MOVWF  29
0319:  MOVF   77,W
031A:  MOVWF  28
031B:  MOVLW  DE
031C:  MOVWF  2F
031D:  MOVLW  FF
031E:  MOVWF  2E
031F:  MOVLW  47
0320:  MOVWF  2D
0321:  MOVLW  7A
0322:  MOVWF  2C
0323:  GOTO   056
0324:  MOVF   7A,W
0325:  MOVWF  27
0326:  MOVF   79,W
0327:  MOVWF  26
0328:  MOVF   78,W
0329:  MOVWF  25
032A:  MOVF   77,W
032B:  MOVWF  24
.................... 		printf("\r%ld\n",adc);  
032C:  MOVLW  0D
032D:  BTFSS  0C.4
032E:  GOTO   32D
032F:  MOVWF  19
0330:  MOVLW  10
0331:  MOVWF  04
0332:  MOVF   23,W
0333:  MOVWF  29
0334:  MOVF   22,W
0335:  MOVWF  28
0336:  GOTO   0CF
0337:  MOVLW  0A
0338:  BTFSS  0C.4
0339:  GOTO   338
033A:  MOVWF  19
.................... 		printf("\rVCC = %f\n",DDD);  
033B:  CLRF   28
033C:  MOVF   28,W
033D:  CALL   012
033E:  INCF   28,F
033F:  MOVWF  77
0340:  MOVF   77,W
0341:  BTFSS  0C.4
0342:  GOTO   341
0343:  MOVWF  19
0344:  MOVLW  07
0345:  SUBWF  28,W
0346:  BTFSS  03.2
0347:  GOTO   33C
0348:  MOVF   27,W
0349:  MOVWF  2C
034A:  MOVF   26,W
034B:  MOVWF  2B
034C:  MOVF   25,W
034D:  MOVWF  2A
034E:  MOVF   24,W
034F:  MOVWF  29
0350:  CLRF   30
0351:  CLRF   2F
0352:  MOVLW  01
0353:  MOVWF  2E
0354:  MOVLW  06
0355:  MOVWF  2D
0356:  GOTO   135
0357:  MOVLW  0A
0358:  BTFSS  0C.4
0359:  GOTO   358
035A:  MOVWF  19
....................   
.................... 	}  
035B:  GOTO   2F3
.................... }  
....................   
....................  
035C:  SLEEP

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT NODEBUG NOPROTECT BROWNOUT NOLVP NOCPD NOWRT
