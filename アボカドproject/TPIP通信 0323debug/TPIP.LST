CCS PCM C Compiler, Version 3.185, 22500

               Filename: D:\Erectric\PIC-project\PIC-project\アボカドproject\TPIP通信 0323\TPIP.LST

               ROM used: 1275 (16%)
                         Largest free fragment is 2048
               RAM used: 57 (33%) at main() level
                         57 (33%) worst case
               Stack:    1 locations

*
0000:  MOVLW  00
0001:  MOVWF  0A
0002:  GOTO   1AA
0003:  NOP
....................  #include<16f877a.h> 
....................  //////// Standard Header file for the PIC16F877A device ////////////////  
.................... #device PIC16F877A  
.................... #list  
....................  
.................... #include<stdio.h> 
....................  ///////////////////////////////////////////////////////////////////////////  
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////  
.................... //// This source code may only be used by licensed users of the CCS C  ////  
.................... //// compiler.  This source code may only be distributed to other      ////  
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////  
.................... //// or distribution is permitted without written permission.          ////  
.................... //// Derivative programs created using this software in object code    ////  
.................... //// form are not restricted in any way.                               ////  
.................... ///////////////////////////////////////////////////////////////////////////  
....................   
.................... #ifndef _STDIO  
.................... #define _STDIO  
.................... #include <string.h> 
....................  ////////////////////////////////////////////////////////////////////////////  
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////  
.................... //// This source code may only be used by licensed users of the CCS C   ////  
.................... //// compiler.  This source code may only be distributed to other       ////  
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////  
.................... //// or distribution is permitted without written permission.           ////  
.................... //// Derivative programs created using this software in object code     ////  
.................... //// form are not restricted in any way.                                ////  
.................... ////////////////////////////////////////////////////////////////////////////  
....................   
.................... #ifndef _STRING  
.................... #define _STRING  
.................... #include <stddef.h> 
....................  ///////////////////////////////////////////////////////////////////////////  
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////  
.................... //// This source code may only be used by licensed users of the CCS C  ////  
.................... //// compiler.  This source code may only be distributed to other      ////  
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////  
.................... //// or distribution is permitted without written permission.          ////  
.................... //// Derivative programs created using this software in object code    ////  
.................... //// form are not restricted in any way.                               ////  
.................... ///////////////////////////////////////////////////////////////////////////  
....................   
.................... #ifndef _STDDEF  
....................   
.................... #define _STDDEF  
....................   
.................... #if sizeof(int *)==1  
.................... #define ptrdiff_t int  
.................... #else  
.................... #define ptrdiff_t long  
.................... #endif  
....................   
.................... #define size_t int  
.................... #define wchar_t char  
.................... #define NULL 0  
....................   
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)  
....................   
.................... #endif  
....................  
.................... #include <ctype.h> 
....................  ////////////////////////////////////////////////////////////////////////////  
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////  
.................... //// This source code may only be used by licensed users of the CCS C   ////  
.................... //// compiler.  This source code may only be distributed to other       ////  
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////  
.................... //// or distribution is permitted without written permission.           ////  
.................... //// Derivative programs created using this software in object code     ////  
.................... //// form are not restricted in any way.                                ////  
.................... ////////////////////////////////////////////////////////////////////////////  
....................   
.................... #ifndef _CTYPE  
.................... #define _CTYPE  
....................   
.................... #define islower(x)  isamoung(x,"abcdefghijklmnopqrstuvwxyz")  
.................... #define isupper(x)  isamoung(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")  
.................... #define isalnum(x)  isamoung(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")  
.................... #define isalpha(x)  isamoung(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")  
.................... #define isdigit(x)  isamoung(x,"0123456789")  
.................... #define isspace(x)  (x==' ')  
.................... #define isxdigit(x) isamoung(x,"0123456789ABCDEFabcdef")  
.................... #define iscntrl(x)  (x<' ')  
.................... #define isprint(x)  (x>=' ')  
.................... #define isgraph(x)  (x>' ')  
.................... #define ispunct(x)  ((x>' ')&&!isalnum(x))  
....................   
.................... #endif  
....................   
....................  
....................   
....................   
....................   
.................... //////////////////////////////////////////////  
.................... //// Uncomment the following define to    ////  
.................... //// allow some functions to use a        ////  
.................... //// quicker algorithm, but use more ROM  ////  
.................... ////                                      ////  
.................... //// #define FASTER_BUT_MORE_ROM          ////  
.................... //////////////////////////////////////////////  
....................   
....................   
....................   
.................... /*Copying functions*/  
.................... /* standard template:  
....................    void *memmove(void *s1, void *s2, size_t n).  
....................    Copies max of n characters safely (not following ending '\0')  
....................    from s2 in s1; if s2 has less than n characters, appends 0 */  
....................   
.................... char *memmove(void *s1,char *s2,size_t n)  
.................... {  
....................    char *sc1;  
....................    char *sc2;  
....................    sc1=s1;  
....................    sc2=s2;  
....................    if(sc2<sc1 && sc1 <sc2 +n)  
....................       for(sc1+=n,sc2+=n;0<n;--n)  
....................          *--sc1=*--sc2;  
....................    else  
....................       for(;0<n;--n)  
....................          *sc1++=*sc2++;  
....................   return s1;  
....................   }  
.................... /*    Standard template: char *strcpy(char *s1, const char *s2)  
.................... copies the string s2 including the null character to s1*/  
....................   
.................... char *strcpy(char *s1, char *s2)  
.................... {  
....................   char *s;  
....................   
....................   for (s = s1; *s2 != 0; s++, s2++)  
.................... 	  *s = *s2;  
....................   return(s1);  
.................... }  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved?? 
....................    Standard template: char *strcpy(char *s1, const char *s2)  
....................    copies the string s2 including the null character to s1*/  
....................   
.................... char *strcopy(char *s1, char *s2)  
.................... {  
....................   char *s;  
....................   
....................   for (s = s1; *s2 != 0; s++, s2++)  
.................... 	  *s = *s2;  
....................   return(s1);  
.................... }  
....................   
.................... /* standard template:  
....................    char *strncpy(char *s1, const char *s2, size_t n).  
....................    Copies max of n characters (not following ending '\0')  
....................    from s2 in s1; if s2 has less than n characters, appends 0 */  
....................   
.................... char *strncpy(char *s1, char *s2, size_t n)  
.................... {  
....................   char *s;  
....................   
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)  
....................      *s++ = *s2++;  
....................   for (; n > 0; n--)  
....................      *s++ = '\0';  
....................   
....................   return(s1);  
.................... }  
.................... /***********************************************************/  
....................   
.................... /*concatenation functions*/  
.................... /* standard template: char *strcat(char *s1, const char *s2)  
.................... appends s2 to s1*/  
....................   
.................... char *strcat(char *s1, char *s2)  
.................... {  
....................    char *s;  
....................   
....................    for (s = s1; *s != '\0'; ++s);  
....................    while(*s2 != '\0')  
....................    {  
....................       *s = *s2;  
....................       ++s;  
....................       ++s2;  
....................    }  
....................   
....................    *s = '\0';  
....................    return(s1);  
.................... }  
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)  
.................... appends not more than n characters from s2 to s1*/  
....................   
.................... char *strncat(char *s1, char *s2, size_t n)  
.................... {  
....................    char *s;  
....................   
....................    for (s = s1; *s != '\0'; ++s);  
....................    while(*s2 != '\0' && 0<n)  
....................    {  
....................       *s = *s2;  
....................       ++s;  
....................       ++s2;  
....................       --n;  
....................    }  
....................   
....................    *s = '\0';  
....................    return(s1);  
.................... }  
....................   
.................... /***********************************************************/  
....................   
.................... /*comparison functions*/  
.................... /* standard template: signed int memcmp(void *s1, void *s2).  
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */  
....................   
.................... signed int memcmp(void * s1,char *s2,size_t n)  
.................... {  
.................... char *su1, su2;  
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)  
.................... {  
....................    if(*su1!=*su2)  
....................       return ((*su1<*su2)??1:+1);  
.................... }  
.................... return 0;  
.................... }  
.................... /* standard template: int strcmp(const char *s1, const char *s2).  
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */  
....................   
.................... signed int strcmp(char *s1, char *s2)  
.................... {  
....................    for (; *s1 == *s2; s1++, s2++)  
....................       if (*s1 == '\0')  
....................          return(0);  
....................    return((*s1 < *s2) ??-1: 1);  
.................... }  
.................... /* standard template: int strcoll(const char *s1, const char *s2).  
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */  
....................   
.................... signed int strcoll(char *s1, char *s2)  
.................... {  
....................    for (; *s1 == *s2; s1++, s2++)  
....................       if (*s1 == '\0')  
....................          return(0);  
....................    return((*s1 < *s2) ??-1: 1);  
.................... }  
....................   
.................... /* standard template:  
....................    int strncmp(const char *s1, const char *s2, size_t n).  
....................    Compares max of n characters (not following 0) from s1 to s2;  
....................    returns same as strcmp */  
....................   
.................... signed int strncmp(char *s1, char *s2, size_t n)  
.................... {  
....................    for (; n > 0; s1++, s2++, n--)  
....................       if (*s1 != *s2)  
....................          return((*s1 <*s2) ??-1: 1);  
....................       else if (*s1 == '\0')  
....................          return(0);  
....................    return(0);  
.................... }  
.................... /* standard template:  
....................    int strxfrm(const char *s1, const char *s2, size_t n).  
....................    transforms maximum of n characters from s2 and places them into s1*/  
.................... size_t strxfrm(char *s1, char *s2, size_t n)  
.................... {  
....................   char *s;  
....................   int n1;  
....................   n1=n;  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)  
....................      *s++ = *s2++;  
....................   for (; n > 0; n--)  
....................      *s++ = '\0';  
....................   
....................   return(n1);  
.................... }  
....................   
....................   
....................   
....................   
....................   
.................... /***********************************************************/  
.................... /*Search functions*/  
.................... /* standard template: void *memchr(const char *s, int c).  
....................    Finds first occurrence of c in n characters of s */  
....................   
.................... char *memchr(void *s,int c,size_t n)  
.................... {  
....................    char uc;  
....................    char *su;  
....................    uc=c;  
....................    for(su=s;0<n;++su,--n)  
....................       if(*su==uc)  
....................       return su;  
....................    return NULL;  
.................... }  
....................   
.................... /* standard template: char *strchr(const char *s, int c).  
....................    Finds first occurrence of c in s */  
....................   
.................... char *strchr(char *s, int c)  
.................... {  
....................    for (; *s != c; s++)  
....................       if (*s == '\0')  
....................          return(0);  
....................    return(s);  
.................... }  
.................... /* standard template:  
....................    size_t strcspn(const char *s1, const char *s2).  
....................    Computes length of max initial segment of s1 that  
....................    consists entirely of characters NOT from s2*/  
....................   
.................... int *strcspn(char *s1, char *s2)  
.................... {  
....................    char *sc1, *sc2;  
....................   
....................    for (sc1 = s1; *sc1 != 0; sc1++)  
....................       for (sc2 = s2; *sc2 != 0; sc2++)  
....................          if (*sc1 == *sc2)  
....................             return(sc1 - s1);  
....................    return(sc1 - s1);  
.................... }  
.................... /* standard template:  
....................    char *strpbrk(const char *s1, const char *s2).  
....................    Locates first occurence of any character from s2 in s1;  
....................    returns s1 if s2 is empty string */  
....................   
.................... char *strpbrk(char *s1, char *s2)  
.................... {  
....................    char *sc1, *sc2;  
....................   
....................    for (sc1 = s1; *sc1 != 0; sc1++)  
....................       for (sc2 = s2; *sc2 != 0; sc2++)  
....................          if (*sc1 == *sc2)  
....................             return(sc1);  
....................    return(0);  
.................... }  
....................   
....................   
.................... /* standard template: char *strrchr(const char *s, int c).  
....................    Finds last occurrence of c in s */  
....................   
.................... char *strrchr(char *s, int c)  
.................... {  
....................    char *p;  
....................   
....................    for (p = 0; ; s++)  
....................    {  
....................       if (*s == c)  
....................          p = s;  
....................       if (*s == '\0')  
....................          return(p);  
....................    }  
.................... }  
.................... /* computes length of max initial segment of s1 consisting  
....................    entirely of characters from s2 */  
....................   
.................... int *strspn(char *s1, char *s2)  
.................... {  
....................    char *sc1, *sc2;  
....................   
....................    for (sc1 = s1; *sc1 != 0; sc1++)  
....................       for (sc2 = s2; ; sc2++)  
.................... 	 if (*sc2 == '\0')  
.................... 	    return(sc1 - s1);  
....................          else if (*sc1 == *sc2)  
....................             break;  
....................    return(sc1 - s1);  
.................... }  
.................... /* standard template:  
....................    char *strstr(const char *s1, const char *s2);  
....................    Locates first occurence of character sequence s2 in s1;  
....................    returns 0 if s2 is empty string  
....................   
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the  
....................    file to use the faster algorithm */  
.................... char *strstr(char *s1, char *s2)  
.................... {  
.................... 	char *s, *t;  
....................   
....................    #ifdef FASTER_BUT_MORE_ROM  
....................    if (*s2 == '\0')  
....................          return(s1);  
....................    #endif  
....................   
.................... 	while (*s1)  
....................    {  
....................       for(s = s1, t = s2; *t && *s == *t; ++s, ++t);  
....................   
.................... 		if (*t == '\0')  
.................... 			return s1;  
....................       ++s1;  
....................       #ifdef FASTER_BUT_MORE_ROM  
....................          while(*s1 != '\0' && *s1 != *s2)  
....................             ++s1;  
....................       #endif  
.................... 	}  
.................... 	return 0;  
.................... }  
....................   
.................... /* standard template: char *strtok(char *s1, const char *s2).  
....................   
....................    Finds next token in s1 delimited by a character from separator  
....................    string s2 (which can be different from call to call).  First call  
....................    starts at beginning of s1 searching for first character NOT  
....................    contained in s2; returns 0 if none is found.  
....................    If one is found, it is the start of first token (return value).  
....................    Function then searches from there for a character contained in s2.  
....................    If none is found, current token extends to end of s1, and subsequent  
....................    searches for a token will return 0.  If one is found, it is  
....................    overwritten by '\0', which terminates current token.  Function saves  
....................    pointer to following character from which next search will start.  
....................    Each subsequent call, with 0 as first argument, starts searching  
....................    from saved pointer */  
....................   
.................... char *strtok(char *s1, char *s2)  
.................... {  
....................    char *beg, *end;  
....................    static char *save;  
*
01B3:  CLRF   20
01B4:  MOVLW  81
01B5:  BSF    03.5
01B6:  MOVWF  19
01B7:  MOVLW  26
01B8:  MOVWF  18
01B9:  MOVLW  90
01BA:  BCF    03.5
01BB:  MOVWF  18
....................   
....................    beg = (s1)??s1: save;  
....................    beg += strspn(beg, s2);  
....................    if (*beg == '\0')  
....................    {  
....................       *save = ' ';  
....................       return(0);  
....................    }  
....................    end = strpbrk(beg, s2);  
....................    if (*end != '\0')  
....................    {  
....................       *end = '\0';  
....................       end++;  
....................    }  
....................    save = end;  
....................    return(beg);  
.................... }  
....................   
.................... /*****************************************************************/  
.................... /*Miscellaneous functions*/  
.................... /* standard template  
.................... maps error number in errnum to an error message string  
.................... Returns: Pointer to string  
.................... */  
.................... #ifdef _ERRNO  
.................... char * strerror(int errnum)  
.................... {  
.................... char s[15];  
.................... switch( errnum)  
.................... {  
.................... case 0:  
....................    strcpy(s,"no errors");  
....................    return s;  
.................... case EDOM :  
....................    strcpy(s,"domain error");  
....................    return s;  
.................... case ERANGE:  
....................    strcpy(s,"range error");  
....................    return s;  
.................... }  
.................... }  
.................... #ENDIF  
.................... /* standard template: size_t strlen(const char *s).  
....................    Computes length of s1 (preceding terminating 0) */  
....................   
.................... int *strlen(char *s)  
.................... {  
....................    char *sc;  
....................   
....................    for (sc = s; *sc != 0; sc++);  
....................    return(sc - s);  
.................... }  
....................   
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).  
....................    Compares s1 to s2 ignoring case (upper vs. lower) */  
....................   
.................... signed int stricmp(char *s1, char *s2)  
.................... {  
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32));  
....................     s1++, s2++)  
....................     if (*s1 == '\0')  
....................        return(0);  
....................  return((*s1 < *s2) ??-1: 1);  
.................... }  
....................   
....................   
.................... /* standard template: char *strlwr(char *s).  
....................    Replaces uppercase letters by lowercase;  
....................    returns pointer to new string s */  
....................   
.................... char *strlwr(char *s)  
.................... {  
....................    char *p;  
....................   
....................    for (p = s; *p != '\0'; p++)  
....................       if (*p >= 'A' && *p <='Z')  
....................          *p += 'a' - 'A';  
....................    return(s);  
.................... }  
....................   
....................   
.................... /************************************************************/  
....................   
....................   
.................... #endif  
....................  
.................... #ifndef getc  
.................... #define getc getch  
.................... #define getchar getch  
.................... #define puts(s) {printf(s); putchar(13); putchar(10);}  
.................... #define putc putchar  
.................... #endif  
.................... /* maps error number to an error message. Writes a sequence of characters to  
.................... stderr stream thus: if s is not null then string pointed to by s follwed by  
.................... a colon (:) and a space and the appropriate error message returned by strerror  
.................... function with argument errno  
....................   
.................... Returns: no value  
.................... */  
....................   
.................... #ifdef _ERRNO  
.................... void perror(char *s)  
.................... {  
....................   if(s)  
....................   fprintf(STDERR,"%s: ",s);  
....................   fprintf(STDERR,"%s\r\n",strerror(errno));  
.................... }  
.................... #endif  
.................... #endif  
....................  
....................   
.................... //#define RS_BAUD		115200  
.................... #define RS_BAUD		9600  
.................... #define RS_TX		PIN_C6  
.................... #define RS_RX		PIN_C7  
.................... #define RUN_LED		PIN_C0  
.................... //ぴんマクロ  
.................... //鉄火巻きモーターI/O  
.................... 	#define	TEKKA_Mortor1_IO_R	PIN_A2  
.................... 	#define	TEKKA_Mortor1_IO_L	PIN_A4  
.................... 	#define	TEKKA_LED			PIN_E1  
.................... 	#define	TEKKA_NOPIN			PIN_E0  
.................... 	#define	TEKKA_Mortor2_IO_R	PIN_A3  
.................... 	#define	TEKKA_Mortor2_IO_L	PIN_A5  
.................... 	//モーターPWM  
.................... 	#define	TEKKA_Mortor1_PWM	PIN_C1  
.................... 	#define	TEKKA_Mortor2_PWM	PIN_C2  
.................... 	//かっぱ巻きモーターI/O  
.................... 	#define	KAPPA_LED1			PIN_D5	  
.................... 	#define	KAPPA_LED2			PIN_D4	  
.................... 	#define	KAPPA_Mortor1_IO_R	PIN_D0	  
.................... 	#define	KAPPA_Mortor1_IO_L	PIN_C3  
.................... 	#define	KAPPA_Mortor2_IO_R	PIN_D2	  
.................... 	#define	KAPPA_Mortor2_IO_L	PIN_D3	  
.................... 	#define	KAPPA_Mortor3_IO_R	PIN_C4	  
.................... 	#define	KAPPA_Mortor3_IO_L	PIN_C5	  
.................... 	#define	KAPPA_Mortor4_IO_R	PIN_D1	  
.................... 	#define	KAPPA_Mortor4_IO_L	PIN_A0	  
....................   
.................... #use delay(clock = 20000000)  
*
0195:  MOVLW  53
0196:  MOVWF  04
0197:  MOVF   00,W
0198:  BTFSC  03.2
0199:  GOTO   1A7
019A:  MOVLW  06
019B:  MOVWF  78
019C:  CLRF   77
019D:  DECFSZ 77,F
019E:  GOTO   19D
019F:  DECFSZ 78,F
01A0:  GOTO   19C
01A1:  MOVLW  7B
01A2:  MOVWF  77
01A3:  DECFSZ 77,F
01A4:  GOTO   1A3
01A5:  DECFSZ 00,F
01A6:  GOTO   19A
01A7:  BCF    0A.3
01A8:  BCF    0A.4
01A9:  GOTO   23E (RETURN)
.................... #fuses HS,NOWDT,NOPROTECT,NOLVP,PUT,BROWNOUT  
.................... #use rs232(BAUD = RS_BAUD , XMIT = RS_TX, RCV = RS_RX)  //rs232c設定  
.................... /*  
.................... #use fast_io(a)  
.................... #use fast_io(b)  
.................... #use fast_io(c)  
.................... #use fast_io(d)  
.................... #use fast_io(e)  
.................... */  
.................... #byte port_a = 5  
.................... #byte port_b = 6  
.................... #byte port_c = 7  
.................... #byte port_d = 8  
.................... #byte port_e = 9  
.................... #byte ADCON1 = 0x9F			//アナログデジタルピン設定	  
.................... main()  
.................... {  
01AA:  CLRF   04
01AB:  MOVLW  1F
01AC:  ANDWF  03,F
01AD:  MOVLW  06
01AE:  BSF    03.5
01AF:  MOVWF  1F
01B0:  MOVLW  07
01B1:  BCF    03.5
01B2:  MOVWF  1F
.................... 	//ローカル変数定義  
.................... 	char cheaker=0;	  
*
01BE:  CLRF   22
.................... 	int data_H[20];  
.................... 	int data_L[20];		//受信データ格納スペース  
.................... 	int16 E=0,F=0;				  
01BF:  CLRF   4B
01C0:  CLRF   4C
01C1:  CLRF   4D
01C2:  CLRF   4E
.................... 	int ID=0,hugou=0,i=0;  
01C3:  CLRF   4F
01C4:  CLRF   50
01C5:  CLRF   51
.................... 	int motasuu=0;  
01C6:  CLRF   52
.................... 	  
.................... 	//初期化  
.................... 	set_tris_a(0x01);  
01C7:  MOVLW  01
01C8:  BSF    03.5
01C9:  MOVWF  05
.................... 	set_tris_b(0x00);  
01CA:  MOVLW  00
01CB:  MOVWF  06
.................... 	set_tris_c(0x80);  
*
01BC:  MOVLW  FF
01BD:  MOVWF  21
*
01CC:  MOVLW  80
01CD:  MOVWF  07
01CE:  BCF    03.5
01CF:  MOVWF  21
.................... 	set_tris_d(0x00);  
01D0:  MOVLW  00
01D1:  BSF    03.5
01D2:  MOVWF  08
.................... 	set_tris_e(0x00);  
01D3:  BCF    09.0
01D4:  BCF    09.1
01D5:  BCF    09.2
.................... 	ADCON1 = 0b00000111;		//デジタルピン設定	  
01D6:  MOVLW  07
01D7:  MOVWF  1F
.................... 	//PWM初期化  
.................... 	setup_ccp1(CCP_PWM);  
01D8:  BCF    03.5
01D9:  BCF    21.2
01DA:  MOVF   21,W
01DB:  BSF    03.5
01DC:  MOVWF  07
01DD:  BCF    03.5
01DE:  BCF    07.2
01DF:  MOVLW  0C
01E0:  MOVWF  17
.................... 	setup_ccp2(CCP_PWM);  
01E1:  BCF    21.1
01E2:  MOVF   21,W
01E3:  BSF    03.5
01E4:  MOVWF  07
01E5:  BCF    03.5
01E6:  BCF    07.1
01E7:  MOVLW  0C
01E8:  MOVWF  1D
.................... 	SETUP_TIMER_2(T2_DIV_BY_16,0xFF,1);  
01E9:  MOVLW  00
01EA:  MOVWF  78
01EB:  IORLW  06
01EC:  MOVWF  12
01ED:  MOVLW  FF
01EE:  BSF    03.5
01EF:  MOVWF  12
.................... 	  
.................... 	//モーター初期化  
.................... 	//鉄火巻き初期化  
.................... 	set_pwm1_duty(0);  
01F0:  BCF    03.5
01F1:  CLRF   15
.................... 	set_pwm2_duty(0);  
01F2:  CLRF   1B
.................... 	output_low(TEKKA_Mortor1_IO_L);  
01F3:  BSF    03.5
01F4:  BCF    05.4
01F5:  BCF    03.5
01F6:  BCF    05.4
.................... 	output_low(TEKKA_Mortor1_IO_R);  
01F7:  BSF    03.5
01F8:  BCF    05.2
01F9:  BCF    03.5
01FA:  BCF    05.2
.................... 	output_low(TEKKA_Mortor2_IO_L);  
01FB:  BSF    03.5
01FC:  BCF    05.5
01FD:  BCF    03.5
01FE:  BCF    05.5
.................... 	output_low(TEKKA_Mortor2_IO_R);  
01FF:  BSF    03.5
0200:  BCF    05.3
0201:  BCF    03.5
0202:  BCF    05.3
.................... 	//かっぱ巻き初期化  
.................... 	output_low(KAPPA_Mortor1_IO_L);  
0203:  BCF    21.3
0204:  MOVF   21,W
0205:  BSF    03.5
0206:  MOVWF  07
0207:  BCF    03.5
0208:  BCF    07.3
.................... 	output_low(KAPPA_Mortor1_IO_R);  
0209:  BSF    03.5
020A:  BCF    08.0
020B:  BCF    03.5
020C:  BCF    08.0
.................... 	output_low(KAPPA_Mortor2_IO_L);  
020D:  BSF    03.5
020E:  BCF    08.3
020F:  BCF    03.5
0210:  BCF    08.3
.................... 	output_low(KAPPA_Mortor2_IO_R);  
0211:  BSF    03.5
0212:  BCF    08.2
0213:  BCF    03.5
0214:  BCF    08.2
.................... 	output_low(KAPPA_Mortor3_IO_L);  
0215:  BCF    21.5
0216:  MOVF   21,W
0217:  BSF    03.5
0218:  MOVWF  07
0219:  BCF    03.5
021A:  BCF    07.5
.................... 	output_low(KAPPA_Mortor3_IO_R);  
021B:  BCF    21.4
021C:  MOVF   21,W
021D:  BSF    03.5
021E:  MOVWF  07
021F:  BCF    03.5
0220:  BCF    07.4
.................... 	output_low(KAPPA_Mortor4_IO_L);  
0221:  BSF    03.5
0222:  BCF    05.0
0223:  BCF    03.5
0224:  BCF    05.0
.................... 	output_low(KAPPA_Mortor4_IO_R);  
0225:  BSF    03.5
0226:  BCF    08.1
0227:  BCF    03.5
0228:  BCF    08.1
.................... 	  
.................... 	  
.................... 	  
.................... 	output_low(RUN_LED);   //動作確認  
0229:  BCF    21.0
022A:  MOVF   21,W
022B:  BSF    03.5
022C:  MOVWF  07
022D:  BCF    03.5
022E:  BCF    07.0
.................... 	output_high(TEKKA_LED);   //動作確認  
022F:  BSF    03.5
0230:  BCF    09.1
0231:  BCF    03.5
0232:  BSF    09.1
.................... 	output_high(KAPPA_LED1);   //動作確認  
0233:  BSF    03.5
0234:  BCF    08.5
0235:  BCF    03.5
0236:  BSF    08.5
.................... 	output_high(KAPPA_LED2);   //動作確認  
0237:  BSF    03.5
0238:  BCF    08.4
0239:  BCF    03.5
023A:  BSF    08.4
.................... 	delay_ms(30);  
023B:  MOVLW  1E
023C:  MOVWF  53
023D:  GOTO   195
.................... 	while(1)  
.................... 	{  
.................... 		while(1)  
.................... 		{	  
.................... 		//スタートデータ待ち  
.................... 			while(!cheaker == '@')  
.................... 			{  
023E:  MOVF   22,F
023F:  BTFSC  03.2
0240:  GOTO   243
0241:  MOVLW  00
0242:  GOTO   244
0243:  MOVLW  01
0244:  SUBLW  40
0245:  BTFSS  03.2
0246:  GOTO   24C
.................... 				cheaker = getc();  
0247:  BTFSS  0C.5
0248:  GOTO   247
0249:  MOVF   1A,W
024A:  MOVWF  22
.................... 			}  
024B:  GOTO   23E
.................... 		//モータの数を確認  
.................... 			motasuu = getc();  
024C:  BTFSS  0C.5
024D:  GOTO   24C
024E:  MOVF   1A,W
024F:  MOVWF  52
.................... 		//データ受信  
.................... 			for(i=0;motasuu > i;i++)  
0250:  CLRF   51
0251:  MOVF   52,W
0252:  SUBWF  51,W
0253:  BTFSC  03.0
0254:  GOTO   265
.................... 			{  
.................... 				data_H[i] =getc();  
0255:  MOVLW  23
0256:  ADDWF  51,W
0257:  MOVWF  04
0258:  BTFSS  0C.5
0259:  GOTO   258
025A:  MOVF   1A,W
025B:  MOVWF  00
.................... 				data_L[i] =getc();  
025C:  MOVLW  37
025D:  ADDWF  51,W
025E:  MOVWF  04
025F:  BTFSS  0C.5
0260:  GOTO   25F
0261:  MOVF   1A,W
0262:  MOVWF  00
.................... 			}  
0263:  INCF   51,F
0264:  GOTO   251
.................... 		//ストップデータ確認  
.................... 			cheaker = getc();  
0265:  BTFSS  0C.5
0266:  GOTO   265
0267:  MOVF   1A,W
0268:  MOVWF  22
.................... 			if(cheaker == '*')  
.................... 			{  
0269:  MOVF   22,W
026A:  SUBLW  2A
026B:  BTFSS  03.2
026C:  GOTO   26E
.................... 				break;  
026D:  GOTO   4F7
.................... 			}  
.................... 		//データ復号  
.................... 			for(i=0;motasuu == i;i++)  
026E:  CLRF   51
026F:  MOVF   51,W
0270:  SUBWF  52,W
0271:  BTFSS  03.2
0272:  GOTO   4F4
.................... 				{  
.................... 					//IDの取り出し  
.................... 					ID = data_H[i] & 0b11111000;  
0273:  MOVLW  23
0274:  ADDWF  51,W
0275:  MOVWF  04
0276:  MOVF   00,W
0277:  ANDLW  F8
0278:  MOVWF  4F
.................... 					ID = ID>>3;  
0279:  RRF    4F,F
027A:  RRF    4F,F
027B:  RRF    4F,F
027C:  MOVLW  1F
027D:  ANDWF  4F,F
.................... 					//符号取り出し  
.................... 					hugou = data_H[i] & 0b0000100;  
027E:  MOVLW  23
027F:  ADDWF  51,W
0280:  MOVWF  04
0281:  MOVF   00,W
0282:  ANDLW  04
0283:  MOVWF  50
.................... 					//PWMデータ取り出し  
.................... 					F = data_H[i] & 0b0000011;		//PWM上位2bit取り出し  
0284:  MOVLW  23
0285:  ADDWF  51,W
0286:  MOVWF  04
0287:  MOVF   00,W
0288:  ANDLW  03
0289:  MOVWF  4D
028A:  CLRF   4E
.................... 					F = F<<8;						//PWMデータを8ビット左にシフト  
028B:  MOVF   4D,W
028C:  MOVWF  4E
028D:  CLRF   4D
.................... 					E = data_L[i];					  
028E:  MOVLW  37
028F:  ADDWF  51,W
0290:  MOVWF  04
0291:  MOVF   00,W
0292:  CLRF   7A
0293:  MOVWF  4B
0294:  MOVF   7A,W
0295:  MOVWF  4C
.................... 					F = F | E;						//PWMのデータの上位と下位をORする(FにPWM用のデータがはいってる)  
0296:  MOVF   4B,W
0297:  IORWF  4D,F
0298:  MOVF   4C,W
0299:  IORWF  4E,F
.................... 					  
.................... 					//PWMデータ判別  
.................... 					if(F <=370 && F != 0)			//ストップではなく、PWMが370以下のとき  
.................... 					{  
029A:  MOVF   4E,W
029B:  SUBLW  01
029C:  BTFSS  03.0
029D:  GOTO   2AE
029E:  BTFSS  03.2
029F:  GOTO   2A4
02A0:  MOVF   4D,W
02A1:  SUBLW  72
02A2:  BTFSS  03.0
02A3:  GOTO   2AE
02A4:  MOVF   4D,F
02A5:  BTFSS  03.2
02A6:  GOTO   2AA
02A7:  MOVF   4E,F
02A8:  BTFSC  03.2
02A9:  GOTO   2AE
.................... 						F = 420;  
02AA:  MOVLW  01
02AB:  MOVWF  4E
02AC:  MOVLW  A4
02AD:  MOVWF  4D
.................... 					}  
.................... 					  
.................... 				//データ実行  
.................... 					switch (ID)						//モーター判別  
.................... 					{  
02AE:  MOVF   4F,W
02AF:  MOVWF  77
02B0:  MOVLW  01
02B1:  SUBWF  77,W
02B2:  BTFSC  03.2
02B3:  GOTO   2C9
02B4:  MOVLW  02
02B5:  SUBWF  77,W
02B6:  BTFSC  03.2
02B7:  GOTO   31B
02B8:  MOVLW  03
02B9:  SUBWF  77,W
02BA:  BTFSC  03.2
02BB:  GOTO   367
02BC:  MOVLW  04
02BD:  SUBWF  77,W
02BE:  BTFSC  03.2
02BF:  GOTO   3BF
02C0:  MOVLW  05
02C1:  SUBWF  77,W
02C2:  BTFSC  03.2
02C3:  GOTO   40B
02C4:  MOVLW  06
02C5:  SUBWF  77,W
02C6:  BTFSC  03.2
02C7:  GOTO   47E
02C8:  GOTO   4F1
.................... 				case 0b00000001:					//かっぱモーター１  
.................... 						if(F)						//モーターが動かす時  
.................... 						{  
02C9:  MOVF   4D,W
02CA:  IORWF  4E,W
02CB:  BTFSC  03.2
02CC:  GOTO   303
.................... 							if(hugou)  
.................... 							{  
02CD:  MOVF   50,F
02CE:  BTFSC  03.2
02CF:  GOTO   2E8
.................... 								printf("かっぱモーター１_R\n\r");  
02D0:  CLRF   53
02D1:  MOVF   53,W
02D2:  CALL   004
02D3:  INCF   53,F
02D4:  MOVWF  77
02D5:  MOVF   77,W
02D6:  BTFSS  0C.4
02D7:  GOTO   2D6
02D8:  MOVWF  19
02D9:  MOVLW  14
02DA:  SUBWF  53,W
02DB:  BTFSS  03.2
02DC:  GOTO   2D1
.................... 								output_high(KAPPA_Mortor1_IO_R);  
02DD:  BSF    03.5
02DE:  BCF    08.0
02DF:  BCF    03.5
02E0:  BSF    08.0
.................... 								output_low(KAPPA_Mortor1_IO_L);  
02E1:  BCF    21.3
02E2:  MOVF   21,W
02E3:  BSF    03.5
02E4:  MOVWF  07
02E5:  BCF    03.5
02E6:  BCF    07.3
.................... 							}else if(!hugou)  
02E7:  GOTO   302
.................... 							{  
02E8:  MOVF   50,F
02E9:  BTFSS  03.2
02EA:  GOTO   302
.................... 								printf("かっぱモーター１_L\n\r");  
02EB:  CLRF   53
02EC:  MOVF   53,W
02ED:  CALL   01D
02EE:  INCF   53,F
02EF:  MOVWF  77
02F0:  MOVF   77,W
02F1:  BTFSS  0C.4
02F2:  GOTO   2F1
02F3:  MOVWF  19
02F4:  MOVLW  14
02F5:  SUBWF  53,W
02F6:  BTFSS  03.2
02F7:  GOTO   2EC
.................... 								output_high(KAPPA_Mortor1_IO_L);  
02F8:  BCF    21.3
02F9:  MOVF   21,W
02FA:  BSF    03.5
02FB:  MOVWF  07
02FC:  BCF    03.5
02FD:  BSF    07.3
.................... 								output_low(KAPPA_Mortor1_IO_R);  
02FE:  BSF    03.5
02FF:  BCF    08.0
0300:  BCF    03.5
0301:  BCF    08.0
.................... 							}  
.................... 						}else						//モーターを動かさないとき  
.................... 						{  
0302:  GOTO   31A
.................... 								printf("かっぱモーター１_else\n\r");  
0303:  CLRF   53
0304:  MOVF   53,W
0305:  CALL   036
0306:  INCF   53,F
0307:  MOVWF  77
0308:  MOVF   77,W
0309:  BTFSS  0C.4
030A:  GOTO   309
030B:  MOVWF  19
030C:  MOVLW  17
030D:  SUBWF  53,W
030E:  BTFSS  03.2
030F:  GOTO   304
.................... 								output_low(KAPPA_Mortor1_IO_L);  
0310:  BCF    21.3
0311:  MOVF   21,W
0312:  BSF    03.5
0313:  MOVWF  07
0314:  BCF    03.5
0315:  BCF    07.3
.................... 								output_low(KAPPA_Mortor1_IO_R);  
0316:  BSF    03.5
0317:  BCF    08.0
0318:  BCF    03.5
0319:  BCF    08.0
.................... 						}  
.................... 					break;  
031A:  GOTO   4F2
.................... 				case 0b00000010:					//かっぱモーター２  
.................... 						if(F)						//モーターが動かす時  
.................... 						{  
031B:  MOVF   4D,W
031C:  IORWF  4E,W
031D:  BTFSC  03.2
031E:  GOTO   351
.................... 							if(hugou)  
.................... 							{  
031F:  MOVF   50,F
0320:  BTFSC  03.2
0321:  GOTO   338
.................... 								printf("かっぱモーター2_R\n\r");  
0322:  CLRF   53
0323:  MOVF   53,W
0324:  CALL   052
0325:  INCF   53,F
0326:  MOVWF  77
0327:  MOVF   77,W
0328:  BTFSS  0C.4
0329:  GOTO   328
032A:  MOVWF  19
032B:  MOVLW  13
032C:  SUBWF  53,W
032D:  BTFSS  03.2
032E:  GOTO   323
.................... 								output_high(KAPPA_Mortor2_IO_R);  
032F:  BSF    03.5
0330:  BCF    08.2
0331:  BCF    03.5
0332:  BSF    08.2
.................... 								output_low(KAPPA_Mortor2_IO_L);  
0333:  BSF    03.5
0334:  BCF    08.3
0335:  BCF    03.5
0336:  BCF    08.3
.................... 							}else if(!hugou)  
0337:  GOTO   350
.................... 							{  
0338:  MOVF   50,F
0339:  BTFSS  03.2
033A:  GOTO   350
.................... 								printf("かっぱモーター2_L\n\r");  
033B:  CLRF   53
033C:  MOVF   53,W
033D:  CALL   06A
033E:  INCF   53,F
033F:  MOVWF  77
0340:  MOVF   77,W
0341:  BTFSS  0C.4
0342:  GOTO   341
0343:  MOVWF  19
0344:  MOVLW  13
0345:  SUBWF  53,W
0346:  BTFSS  03.2
0347:  GOTO   33C
.................... 								output_high(KAPPA_Mortor2_IO_L);  
0348:  BSF    03.5
0349:  BCF    08.3
034A:  BCF    03.5
034B:  BSF    08.3
.................... 								output_low(KAPPA_Mortor2_IO_R);  
034C:  BSF    03.5
034D:  BCF    08.2
034E:  BCF    03.5
034F:  BCF    08.2
.................... 							}  
.................... 						}else						//モーターを動かさないとき  
.................... 						{  
0350:  GOTO   366
.................... 								printf("かっぱモーター2_else\n\r");  
0351:  CLRF   53
0352:  MOVF   53,W
0353:  CALL   082
0354:  INCF   53,F
0355:  MOVWF  77
0356:  MOVF   77,W
0357:  BTFSS  0C.4
0358:  GOTO   357
0359:  MOVWF  19
035A:  MOVLW  16
035B:  SUBWF  53,W
035C:  BTFSS  03.2
035D:  GOTO   352
.................... 								output_low(KAPPA_Mortor2_IO_L);  
035E:  BSF    03.5
035F:  BCF    08.3
0360:  BCF    03.5
0361:  BCF    08.3
.................... 								output_low(KAPPA_Mortor2_IO_R);  
0362:  BSF    03.5
0363:  BCF    08.2
0364:  BCF    03.5
0365:  BCF    08.2
.................... 						}  
.................... 					break;  
0366:  GOTO   4F2
.................... 				case 0b00000011:					//かっぱモーター３  
.................... 						if(F)						//モーターが動かす時  
.................... 						{  
0367:  MOVF   4D,W
0368:  IORWF  4E,W
0369:  BTFSC  03.2
036A:  GOTO   3A5
.................... 							printf("かっぱモーター3_R\n\r");  
036B:  CLRF   53
036C:  MOVF   53,W
036D:  CALL   09D
036E:  INCF   53,F
036F:  MOVWF  77
0370:  MOVF   77,W
0371:  BTFSS  0C.4
0372:  GOTO   371
0373:  MOVWF  19
0374:  MOVLW  13
0375:  SUBWF  53,W
0376:  BTFSS  03.2
0377:  GOTO   36C
.................... 							if(hugou)  
.................... 							{  
0378:  MOVF   50,F
0379:  BTFSC  03.2
037A:  GOTO   388
.................... 								output_high(KAPPA_Mortor3_IO_R);  
037B:  BCF    21.4
037C:  MOVF   21,W
037D:  BSF    03.5
037E:  MOVWF  07
037F:  BCF    03.5
0380:  BSF    07.4
.................... 								output_low(KAPPA_Mortor3_IO_L);  
0381:  BCF    21.5
0382:  MOVF   21,W
0383:  BSF    03.5
0384:  MOVWF  07
0385:  BCF    03.5
0386:  BCF    07.5
.................... 							}else if(!hugou)  
0387:  GOTO   3A4
.................... 							{  
0388:  MOVF   50,F
0389:  BTFSS  03.2
038A:  GOTO   3A4
.................... 								printf("かっぱモーター3_L\n\r");  
038B:  CLRF   53
038C:  MOVF   53,W
038D:  CALL   0B5
038E:  INCF   53,F
038F:  MOVWF  77
0390:  MOVF   77,W
0391:  BTFSS  0C.4
0392:  GOTO   391
0393:  MOVWF  19
0394:  MOVLW  13
0395:  SUBWF  53,W
0396:  BTFSS  03.2
0397:  GOTO   38C
.................... 								output_high(KAPPA_Mortor3_IO_L);  
0398:  BCF    21.5
0399:  MOVF   21,W
039A:  BSF    03.5
039B:  MOVWF  07
039C:  BCF    03.5
039D:  BSF    07.5
.................... 								output_low(KAPPA_Mortor3_IO_R);  
039E:  BCF    21.4
039F:  MOVF   21,W
03A0:  BSF    03.5
03A1:  MOVWF  07
03A2:  BCF    03.5
03A3:  BCF    07.4
.................... 							}  
.................... 						}else						//モーターを動かさないとき  
.................... 						{  
03A4:  GOTO   3BE
.................... 								printf("かっぱモーター3_else\n\r");  
03A5:  CLRF   53
03A6:  MOVF   53,W
03A7:  CALL   0CD
03A8:  INCF   53,F
03A9:  MOVWF  77
03AA:  MOVF   77,W
03AB:  BTFSS  0C.4
03AC:  GOTO   3AB
03AD:  MOVWF  19
03AE:  MOVLW  16
03AF:  SUBWF  53,W
03B0:  BTFSS  03.2
03B1:  GOTO   3A6
.................... 								output_low(KAPPA_Mortor3_IO_L);  
03B2:  BCF    21.5
03B3:  MOVF   21,W
03B4:  BSF    03.5
03B5:  MOVWF  07
03B6:  BCF    03.5
03B7:  BCF    07.5
.................... 								output_low(KAPPA_Mortor3_IO_R);  
03B8:  BCF    21.4
03B9:  MOVF   21,W
03BA:  BSF    03.5
03BB:  MOVWF  07
03BC:  BCF    03.5
03BD:  BCF    07.4
.................... 						}  
.................... 					break;  
03BE:  GOTO   4F2
.................... 				case 0b00000100:					//かっぱモーター４  
.................... 						if(F)						//モーターが動かす時  
.................... 						{  
03BF:  MOVF   4D,W
03C0:  IORWF  4E,W
03C1:  BTFSC  03.2
03C2:  GOTO   3F5
.................... 							if(hugou)  
.................... 							{  
03C3:  MOVF   50,F
03C4:  BTFSC  03.2
03C5:  GOTO   3DC
.................... 								printf("かっぱモーター4_R\n\r");  
03C6:  CLRF   53
03C7:  MOVF   53,W
03C8:  CALL   0E8
03C9:  INCF   53,F
03CA:  MOVWF  77
03CB:  MOVF   77,W
03CC:  BTFSS  0C.4
03CD:  GOTO   3CC
03CE:  MOVWF  19
03CF:  MOVLW  13
03D0:  SUBWF  53,W
03D1:  BTFSS  03.2
03D2:  GOTO   3C7
.................... 								output_high(KAPPA_Mortor4_IO_R);  
03D3:  BSF    03.5
03D4:  BCF    08.1
03D5:  BCF    03.5
03D6:  BSF    08.1
.................... 								output_low(KAPPA_Mortor4_IO_L);  
03D7:  BSF    03.5
03D8:  BCF    05.0
03D9:  BCF    03.5
03DA:  BCF    05.0
.................... 							}else if(!hugou)  
03DB:  GOTO   3F4
.................... 							{  
03DC:  MOVF   50,F
03DD:  BTFSS  03.2
03DE:  GOTO   3F4
.................... 								printf("かっぱモーター4_L\n\r");  
03DF:  CLRF   53
03E0:  MOVF   53,W
03E1:  CALL   100
03E2:  INCF   53,F
03E3:  MOVWF  77
03E4:  MOVF   77,W
03E5:  BTFSS  0C.4
03E6:  GOTO   3E5
03E7:  MOVWF  19
03E8:  MOVLW  13
03E9:  SUBWF  53,W
03EA:  BTFSS  03.2
03EB:  GOTO   3E0
.................... 								output_high(KAPPA_Mortor4_IO_L);  
03EC:  BSF    03.5
03ED:  BCF    05.0
03EE:  BCF    03.5
03EF:  BSF    05.0
.................... 								output_low(KAPPA_Mortor4_IO_R);  
03F0:  BSF    03.5
03F1:  BCF    08.1
03F2:  BCF    03.5
03F3:  BCF    08.1
.................... 							}  
.................... 						}else						//モーターを動かさないとき  
.................... 						{  
03F4:  GOTO   40A
.................... 								printf("かっぱモーター4_else\n\r");  
03F5:  CLRF   53
03F6:  MOVF   53,W
03F7:  CALL   118
03F8:  INCF   53,F
03F9:  MOVWF  77
03FA:  MOVF   77,W
03FB:  BTFSS  0C.4
03FC:  GOTO   3FB
03FD:  MOVWF  19
03FE:  MOVLW  16
03FF:  SUBWF  53,W
0400:  BTFSS  03.2
0401:  GOTO   3F6
.................... 								output_low(KAPPA_Mortor4_IO_L);  
0402:  BSF    03.5
0403:  BCF    05.0
0404:  BCF    03.5
0405:  BCF    05.0
.................... 								output_low(KAPPA_Mortor4_IO_R);  
0406:  BSF    03.5
0407:  BCF    08.1
0408:  BCF    03.5
0409:  BCF    08.1
.................... 						}  
.................... 					break;  
040A:  GOTO   4F2
.................... 				case 0b00000101:					//鉄火巻きモーター１  
.................... 						if(F)						//モーターが動かす時  
.................... 						{  
040B:  MOVF   4D,W
040C:  IORWF  4E,W
040D:  BTFSC  03.2
040E:  GOTO   467
.................... 							if(hugou)  
.................... 							{  
040F:  MOVF   50,F
0410:  BTFSC  03.2
0411:  GOTO   43B
.................... 								printf("tekka1_R\n\r");  
0412:  CLRF   53
0413:  MOVF   53,W
0414:  CALL   133
0415:  INCF   53,F
0416:  MOVWF  77
0417:  MOVF   77,W
0418:  BTFSS  0C.4
0419:  GOTO   418
041A:  MOVWF  19
041B:  MOVLW  0A
041C:  SUBWF  53,W
041D:  BTFSS  03.2
041E:  GOTO   413
.................... 								output_high(TEKKA_Mortor1_IO_R);  
041F:  BSF    03.5
0420:  BCF    05.2
0421:  BCF    03.5
0422:  BSF    05.2
.................... 								output_low(TEKKA_Mortor1_IO_L);  
0423:  BSF    03.5
0424:  BCF    05.4
0425:  BCF    03.5
0426:  BCF    05.4
.................... 								set_pwm1_duty(F);  
0427:  MOVF   4E,W
0428:  MOVWF  79
0429:  MOVF   4D,W
042A:  MOVWF  78
042B:  RRF    79,F
042C:  RRF    78,F
042D:  RRF    79,F
042E:  RRF    78,F
042F:  RRF    79,F
0430:  MOVF   78,W
0431:  MOVWF  15
0432:  RRF    79,F
0433:  RRF    79,W
0434:  ANDLW  30
0435:  MOVWF  77
0436:  MOVF   17,W
0437:  ANDLW  CF
0438:  IORWF  77,W
0439:  MOVWF  17
.................... 							}else if(!hugou)  
043A:  GOTO   466
.................... 							{  
043B:  MOVF   50,F
043C:  BTFSS  03.2
043D:  GOTO   466
.................... 								printf("tekka１_L\n\r");  
043E:  CLRF   53
043F:  MOVF   53,W
0440:  CALL   142
0441:  INCF   53,F
0442:  MOVWF  77
0443:  MOVF   77,W
0444:  BTFSS  0C.4
0445:  GOTO   444
0446:  MOVWF  19
0447:  MOVLW  0B
0448:  SUBWF  53,W
0449:  BTFSS  03.2
044A:  GOTO   43F
.................... 								output_high(TEKKA_Mortor1_IO_L);  
044B:  BSF    03.5
044C:  BCF    05.4
044D:  BCF    03.5
044E:  BSF    05.4
.................... 								output_low(TEKKA_Mortor1_IO_R);  
044F:  BSF    03.5
0450:  BCF    05.2
0451:  BCF    03.5
0452:  BCF    05.2
.................... 								set_pwm1_duty(F);  
0453:  MOVF   4E,W
0454:  MOVWF  79
0455:  MOVF   4D,W
0456:  MOVWF  78
0457:  RRF    79,F
0458:  RRF    78,F
0459:  RRF    79,F
045A:  RRF    78,F
045B:  RRF    79,F
045C:  MOVF   78,W
045D:  MOVWF  15
045E:  RRF    79,F
045F:  RRF    79,W
0460:  ANDLW  30
0461:  MOVWF  77
0462:  MOVF   17,W
0463:  ANDLW  CF
0464:  IORWF  77,W
0465:  MOVWF  17
.................... 							}  
.................... 						}else						//モーターを動かさないとき  
.................... 						{  
0466:  GOTO   47D
.................... 							printf("tekka１_else\n\r");  
0467:  CLRF   53
0468:  MOVF   53,W
0469:  CALL   152
046A:  INCF   53,F
046B:  MOVWF  77
046C:  MOVF   77,W
046D:  BTFSS  0C.4
046E:  GOTO   46D
046F:  MOVWF  19
0470:  MOVLW  0E
0471:  SUBWF  53,W
0472:  BTFSS  03.2
0473:  GOTO   468
.................... 							set_pwm1_duty(0);  
0474:  CLRF   15
.................... 							output_low(TEKKA_Mortor1_IO_L);  
0475:  BSF    03.5
0476:  BCF    05.4
0477:  BCF    03.5
0478:  BCF    05.4
.................... 							output_low(TEKKA_Mortor1_IO_R);  
0479:  BSF    03.5
047A:  BCF    05.2
047B:  BCF    03.5
047C:  BCF    05.2
.................... 						}  
.................... 					break;  
047D:  GOTO   4F2
.................... 				case 0b00000110:					//鉄火巻きモーター２  
.................... 						if(F)						//モーターが動かす時  
.................... 						{  
047E:  MOVF   4D,W
047F:  IORWF  4E,W
0480:  BTFSC  03.2
0481:  GOTO   4DA
.................... 							if(hugou)  
.................... 							{  
0482:  MOVF   50,F
0483:  BTFSC  03.2
0484:  GOTO   4AE
.................... 								printf("tekka2_R\n\r");  
0485:  CLRF   53
0486:  MOVF   53,W
0487:  CALL   165
0488:  INCF   53,F
0489:  MOVWF  77
048A:  MOVF   77,W
048B:  BTFSS  0C.4
048C:  GOTO   48B
048D:  MOVWF  19
048E:  MOVLW  0A
048F:  SUBWF  53,W
0490:  BTFSS  03.2
0491:  GOTO   486
.................... 								output_high(TEKKA_Mortor2_IO_R);  
0492:  BSF    03.5
0493:  BCF    05.3
0494:  BCF    03.5
0495:  BSF    05.3
.................... 								output_low(TEKKA_Mortor2_IO_L);  
0496:  BSF    03.5
0497:  BCF    05.5
0498:  BCF    03.5
0499:  BCF    05.5
.................... 								set_pwm2_duty(F);  
049A:  MOVF   4E,W
049B:  MOVWF  79
049C:  MOVF   4D,W
049D:  MOVWF  78
049E:  RRF    79,F
049F:  RRF    78,F
04A0:  RRF    79,F
04A1:  RRF    78,F
04A2:  RRF    79,F
04A3:  MOVF   78,W
04A4:  MOVWF  1B
04A5:  RRF    79,F
04A6:  RRF    79,W
04A7:  ANDLW  30
04A8:  MOVWF  77
04A9:  MOVF   1D,W
04AA:  ANDLW  CF
04AB:  IORWF  77,W
04AC:  MOVWF  1D
.................... 							}else if(!hugou)  
04AD:  GOTO   4D9
.................... 							{  
04AE:  MOVF   50,F
04AF:  BTFSS  03.2
04B0:  GOTO   4D9
.................... 								printf("tekka2_L\n\r");  
04B1:  CLRF   53
04B2:  MOVF   53,W
04B3:  CALL   174
04B4:  INCF   53,F
04B5:  MOVWF  77
04B6:  MOVF   77,W
04B7:  BTFSS  0C.4
04B8:  GOTO   4B7
04B9:  MOVWF  19
04BA:  MOVLW  0A
04BB:  SUBWF  53,W
04BC:  BTFSS  03.2
04BD:  GOTO   4B2
.................... 								output_high(TEKKA_Mortor2_IO_L);  
04BE:  BSF    03.5
04BF:  BCF    05.5
04C0:  BCF    03.5
04C1:  BSF    05.5
.................... 								output_low(TEKKA_Mortor2_IO_R);  
04C2:  BSF    03.5
04C3:  BCF    05.3
04C4:  BCF    03.5
04C5:  BCF    05.3
.................... 								set_pwm2_duty(F);  
04C6:  MOVF   4E,W
04C7:  MOVWF  79
04C8:  MOVF   4D,W
04C9:  MOVWF  78
04CA:  RRF    79,F
04CB:  RRF    78,F
04CC:  RRF    79,F
04CD:  RRF    78,F
04CE:  RRF    79,F
04CF:  MOVF   78,W
04D0:  MOVWF  1B
04D1:  RRF    79,F
04D2:  RRF    79,W
04D3:  ANDLW  30
04D4:  MOVWF  77
04D5:  MOVF   1D,W
04D6:  ANDLW  CF
04D7:  IORWF  77,W
04D8:  MOVWF  1D
.................... 							}  
.................... 						}else						//モーターを動かさないとき  
.................... 						{  
04D9:  GOTO   4F0
.................... 							printf("tekka2_else\n\r");  
04DA:  CLRF   53
04DB:  MOVF   53,W
04DC:  CALL   183
04DD:  INCF   53,F
04DE:  MOVWF  77
04DF:  MOVF   77,W
04E0:  BTFSS  0C.4
04E1:  GOTO   4E0
04E2:  MOVWF  19
04E3:  MOVLW  0D
04E4:  SUBWF  53,W
04E5:  BTFSS  03.2
04E6:  GOTO   4DB
.................... 							set_pwm2_duty(0);  
04E7:  CLRF   1B
.................... 							output_low(TEKKA_Mortor2_IO_L);  
04E8:  BSF    03.5
04E9:  BCF    05.5
04EA:  BCF    03.5
04EB:  BCF    05.5
.................... 							output_low(TEKKA_Mortor2_IO_R);  
04EC:  BSF    03.5
04ED:  BCF    05.3
04EE:  BCF    03.5
04EF:  BCF    05.3
.................... 						}  
.................... 					break;  
04F0:  GOTO   4F2
.................... 				default:  
.................... 					break;  
04F1:  GOTO   4F2
.................... 					  
.................... 					}  
.................... 					  
.................... 				}  
04F2:  INCF   51,F
04F3:  GOTO   26F
.................... 		//変数初期化  
.................... 			cheaker=0;  
04F4:  CLRF   22
.................... 			motasuu=0;  
04F5:  CLRF   52
.................... 		}  
04F6:  GOTO   23E
.................... 	}  
04F7:  GOTO   23E
.................... 	return(0);  
04F8:  MOVLW  00
04F9:  MOVWF  78
.................... } 
04FA:  SLEEP

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT NODEBUG NOPROTECT BROWNOUT NOLVP NOCPD NOWRT
